// preact.config.js
  const results = helpers.getLoadersByName(config, 'postcss-loader');
  for (const result of results) {
    result.loader.options.plugins = [
      tailwindcss('./tailwind.config.js'),
      // other postcss plugins can be added here
      ...result.loader.options.plugins
    ];
  }


/* src/App.css */
@import "tailwindcss";

@tailwind base;
@tailwind components;
@tailwind utilities;

:root {
  /* Default Light Theme Values */
  /* Backgrounds */
  --color-bg-app: #ffffff;         /* white */
  --color-bg-surface: #f9fafb;     /* gray-50 */
  --color-bg-surface-alt: #f3f4f6; /* gray-100 */
  --color-bg-hover: #eff6ff;       /* blue-50 (for accent hover) or gray-100 for neutral */
  --color-bg-active: #dbeafe;      /* blue-100 (for accent active) or gray-200 for neutral */

  /* Text */
  --color-text-default: #111827;   /* gray-900 */
  --color-text-subtle: #4b5563;    /* gray-600 */
  --color-text-muted: #9ca3af;     /* gray-400 */
  --color-text-on-accent: #ffffff; /* white */
  --color-text-on-destructive: #ffffff; /* white */
  --color-text-link: #2563eb;      /* blue-600 */

  /* Borders & Dividers */
  --color-border-strong: #d1d5db;  /* gray-300 */
  --color-border-subtle: #e5e7eb;  /* gray-200 */
  --color-border-divider: #f3f4f6; /* gray-100 */

  /* Accents */
  --color-accent-emphasis: #2563eb; /* blue-600 */
  --color-accent-emphasis-hover: #1d4ed8; /* blue-700 */
  --color-accent-subtle-bg: #eff6ff;    /* blue-50 */
  --color-accent-destructive: #dc2626; /* red-600 */
  --color-accent-destructive-hover: #b91c1c; /* red-700 */
  --color-accent-success: #16a34a;  /* green-600 */
  --color-accent-warning: #f59e0b;  /* amber-500 */
  --color-accent-info: #0ea5e9;     /* sky-500 */

  /* Shadow */
  --color-shadow: rgba(0,0,0, 0.1);
  --tw-shadow-color: var(--color-shadow);

  /* --- MDC Theme Variable Overrides --- */
  --mdc-theme-primary: var(--color-accent-emphasis);
  --mdc-theme-secondary: var(--color-accent-emphasis); /* Often used by Switch */
  --mdc-theme-on-primary: var(--color-text-on-accent);
  --mdc-theme-on-secondary: var(--color-text-on-accent);

  --mdc-theme-surface: var(--color-bg-surface);
  --mdc-theme-on-surface: var(--color-text-default);
  --mdc-theme-background: var(--color-bg-app);
  --mdc-theme-on-background: var(--color-text-default);

  --mdc-text-field-outlined-idle-border-color: var(--color-border-subtle);
  --mdc-text-field-outlined-hover-border-color: var(--color-border-strong);
  --mdc-select-outlined-idle-border-color: var(--color-border-subtle);
  --mdc-select-outlined-hover-border-color: var(--color-border-strong);

  --mdc-theme-text-primary-on-background: var(--color-text-default);
  --mdc-theme-text-secondary-on-background: var(--color-text-subtle);
  --mdc-theme-text-hint-on-background: var(--color-text-muted);
  --mdc-theme-text-disabled-on-background: var(--color-text-muted);

  --mdc-theme-text-primary-on-surface: var(--color-text-default);
  --mdc-theme-text-secondary-on-surface: var(--color-text-subtle);
  --mdc-theme-error: var(--color-accent-destructive); /* MDC error color */
}

body {
  font-family: system-ui, -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, Cantarell, 'Open Sans', 'Helvetica Neue', sans-serif;
  background-color: var(--color-bg-app);
  color: var(--color-text-default);
  margin: 0;
  -webkit-font-smoothing: antialiased;
  -moz-osx-font-smoothing: grayscale;
  transition: background-color 0.2s ease-in-out, color 0.2s ease-in-out;
}

/* Generic smooth transitions for elements using these vars */
.bg-app, .bg-surface, .bg-surface-alt, .text-default, .text-subtle, .text-muted, .border-strong, .border-subtle {
  transition: background-color 0.2s ease-in-out, color 0.2s ease-in-out, border-color 0.2s ease-in-out;
}

/* --- Theme: Default Dark --- */
html.theme-default-dark {
  /* Backgrounds */
  --color-bg-app: #111827;         /* gray-900 */
  --color-bg-surface: #1f2937;     /* gray-800 */
  --color-bg-surface-alt: #374151; /* gray-700 */
  --color-bg-hover: #3b82f633;       /* blue-500 with opacity or gray-700 */
  --color-bg-active: #3b82f655;      /* blue-500 with more opacity or gray-600 */

  /* Text */
  --color-text-default: #f3f4f6;   /* gray-100 */
  --color-text-subtle: #9ca3af;    /* gray-400 */
  --color-text-muted: #6b7280;     /* gray-500 */
  --color-text-on-accent: #ffffff; /* white or very dark gray for light accents */
  --color-text-on-destructive: #ffffff;
  --color-text-link: #60a5fa;      /* blue-400 */

  /* Borders & Dividers */
  --color-border-strong: #4b5563;  /* gray-600 */
  --color-border-subtle: #374151;  /* gray-700 */
  --color-border-divider: #1f2937; /* gray-800 */

  /* Accents */
  --color-accent-emphasis: #3b82f6; /* blue-500 */
  --color-accent-emphasis-hover: #60a5fa; /* blue-400 */
  --color-accent-subtle-bg: #1e40af2A;    /* blue-700 with opacity */
  --color-accent-destructive: #f87171; /* red-400 */
  --color-accent-destructive-hover: #ef4444; /* red-500 */
  --color-accent-success: #4ade80;  /* green-400 */
  --color-accent-warning: #facc15;  /* yellow-400 */
  --color-accent-info: #38bdf8;     /* sky-400 */

  /* Shadow */
  --color-shadow: rgba(0,0,0, 0.3); /* Darker shadow for dark themes */
  --mdc-theme-on-primary: #000000; /* Black text for lighter blue accent in dark mode */
}

/* --- Theme: Catppuccin Latte --- */
/* Using Catppuccin palette names: https://github.com/catppuccin/palette/blob/main/latte.json */
html.theme-catppuccin-latte {
  /* Backgrounds */
  --color-bg-app: #eff1f5;         /* base */
  --color-bg-surface: #e6e9ef;     /* mantle */
  --color-bg-surface-alt: #dce0e8; /* crust */
  --color-bg-hover: #ccd0da;       /* surface0 */
  --color-bg-active: #bcc0cc;      /* surface1 */

  /* Text */
  --color-text-default: #4c4f69;   /* text */
  --color-text-subtle: #6c6f85;    /* subtext0 */
  --color-text-muted: #9ca0b0;     /* overlay1 */
  --color-text-on-accent: #eff1f5; /* base (on blue) */
  --color-text-on-destructive: #eff1f5; /* base (on red) */
  --color-text-link: #1e66f5;      /* blue */

  /* Borders & Dividers */
  --color-border-strong: #bcc0cc;  /* overlay0 / surface1 */
  --color-border-subtle: #ccd0da;  /* surface2 */
  --color-border-divider: #acb0be; /* overlay2 */

  /* Accents */
  --color-accent-emphasis: #1e66f5; /* blue */
  --color-accent-emphasis-hover: #1759e0; /* slightly darker blue */
  --color-accent-subtle-bg: #e6e9efcc; /* mantle with opacity or a very light blue */
  --color-accent-destructive: #d20f39; /* red */
  --color-accent-destructive-hover: #b00b2f; /* darker red */
  --color-accent-success: #40a02b;  /* green */
  --color-accent-warning: #df8e1d;  /* yellow */
  --color-accent-info: #40a02b;     /* sky */

  /* Shadow */
  --color-shadow: rgba(108, 111, 133, 0.15); /* subtext0 with alpha */
  --mdc-theme-on-primary: #eff1f5;
}

/* --- Theme: Catppuccin Mocha --- */
/* Using Catppuccin palette names: https://github.com/catppuccin/palette/blob/main/mocha.json */
html.theme-catppuccin-mocha {
  /* Backgrounds */
  --color-bg-app: #1e1e2e;         /* base */
  --color-bg-surface: #181825;     /* mantle */
  --color-bg-surface-alt: #11111b; /* crust */
  --color-bg-hover: #313244;       /* surface0 */
  --color-bg-active: #45475a;      /* surface1 */

  /* Text */
  --color-text-default: #cdd6f4;   /* text */
  --color-text-subtle: #a6adc8;    /* subtext0 */
  --color-text-muted: #6c7086;     /* overlay1 */
  --color-text-on-accent: #1e1e2e; /* base (on blue) */
  --color-text-on-destructive: #1e1e2e; /* base (on red) */
  --color-text-link: #89b4fa;      /* blue */

  /* Borders & Dividers */
  --color-border-strong: #45475a;  /* surface1 */
  --color-border-subtle: #313244;  /* surface0 */
  --color-border-divider: #585b70; /* surface2 */

  /* Accents */
  --color-accent-emphasis: #89b4fa; /* blue */
  --color-accent-emphasis-hover: #73a5f9; /* slightly lighter blue (Mocha accents are light) */
  --color-accent-subtle-bg: #89b4fa1A;    /* blue with low opacity */
  --color-accent-destructive: #f38ba8; /* red */
  --color-accent-destructive-hover: #e97693; /* lighter red */
  --color-accent-success: #a6e3a1;  /* green */
  --color-accent-warning: #f9e2af;  /* yellow */
  --color-accent-info: #89dceb;     /* sky */

  /* Shadow */
  --color-shadow: rgba(24, 24, 37, 0.3); /* mantle with alpha */
  --mdc-theme-on-primary: #1e1e2e;
}


/* ============================================== */
/* PREACT MATERIAL COMPONENTS (MDC) OVERRIDES     */
/* ============================================== */

/* General List Item styling */
.mdc-list-item__primary-text {
  color: var(--color-text-default) !important;
}
.mdc-list-item__secondary-text {
  color: var(--color-text-subtle) !important; /* Use the new subtle text color */
}
.mdc-list-item:hover:not(.mdc-list-item--disabled) {
    background-color: var(--color-bg-hover) !important;
}


/* Select Component */
.mdc-select:not(.mdc-select--disabled) .mdc-select__selected-text {
  color: var(--color-text-default) !important;
}
.mdc-select__dropdown-icon {
  fill: var(--color-text-subtle) !important;
}


.mdc-select__native-control {
  color: var(--color-text-default) !important;
  background: var(--color-bg-surface-alt) !important;
  border-color: var(--color-border-secondary) !important;
}

.mdc-select--outlined:not(.mdc-select--disabled) .mdc-notched-outline__leading,
.mdc-select--outlined:not(.mdc-select--disabled) .mdc-notched-outline__notch,
.mdc-select--outlined:not(.mdc-select--disabled) .mdc-notched-outline__trailing {
  border-color: var(--color-border-subtle) !important;
}
.mdc-select--outlined.mdc-select--focused:not(.mdc-select--disabled) .mdc-notched-outline__leading,
.mdc-select--outlined.mdc-select--focused:not(.mdc-select--disabled) .mdc-notched-outline__notch,
.mdc-select--outlined.mdc-select--focused:not(.mdc-select--disabled) .mdc-notched-outline__trailing {
  border-color: var(--color-accent-emphasis) !important;
  border-width: 2px !important;
}
.mdc-select--filled:not(.mdc-select--disabled) {
    background-color: var(--color-bg-surface-alt) !important; /* Use surface-alt for filled background */
}


/* Select Dropdown Menu (MDC Menu) */
.mdc-menu-surface.mdc-select__menu {
  background-color: var(--color-bg-surface) !important;
  color: var(--color-text-default) !important;
  border: 1px solid var(--color-border-strong) !important;
  box-shadow: 0 4px 12px var(--color-shadow) !important; /* Themed shadow */
}
.mdc-menu-surface.mdc-select__menu .mdc-list-item {
  color: var(--color-text-default) !important;
}
.mdc-menu-surface.mdc-select__menu .mdc-list-item:hover:not(.mdc-list-item--selected):not(.mdc-list-item--activated):not(.mdc-list-item--disabled) {
    background-color: var(--color-bg-hover) !important;
}
.mdc-menu-surface.mdc-select__menu .mdc-list-item--selected,
.mdc-menu-surface.mdc-select__menu .mdc-list-item--activated,
.mdc-menu-surface.mdc-select__menu .mdc-list-item[aria-selected="true"] {
  background-color: var(--color-accent-emphasis) !important;
  color: var(--color-text-on-accent) !important;
}


/* Switch Component */
.mdc-switch:not(.mdc-switch--disabled) .mdc-switch__track {
  background-color: var(--color-border-strong) !important; /* Unchecked track color */
  border-color: var(--color-border-strong) !important;
}
.mdc-switch.mdc-switch--checked:not(.mdc-switch--disabled) .mdc-switch__track {
  background-color: var(--color-accent-emphasis) !important;
  border-color: var(--color-accent-emphasis) !important;
}
.mdc-switch:not(.mdc-switch--disabled) .mdc-switch__thumb-underlay .mdc-switch__thumb {
  /* Thumb often white or a very light/dark color depending on theme */
  background-color: #ffffff !important; /* Keeping it white for light themes */
  border-color: #ffffff !important;
}
html.theme-default-dark .mdc-switch:not(.mdc-switch--disabled) .mdc-switch__thumb-underlay .mdc-switch__thumb,
html.theme-catppuccin-mocha .mdc-switch:not(.mdc-switch--disabled) .mdc-switch__thumb-underlay .mdc-switch__thumb {
  background-color: var(--color-bg-surface-alt) !important; /* Darker thumb for dark themes */
  border-color: var(--color-bg-surface-alt) !important;
}
/* Checked thumb can be the same as the track or contrasting */
.mdc-switch.mdc-switch--checked:not(.mdc-switch--disabled) .mdc-switch__thumb-underlay .mdc-switch__thumb {
  background-color: var(--color-accent-emphasis) !important;
  /* Or for a contrasting thumb: background-color: var(--color-text-on-accent) !important; */
}

/* Input fields (native) */
input[type="number"], input[type="text"], input[type="email"], input[type="password"], textarea {
  background-color: var(--color-bg-surface) !important;
  color: var(--color-text-default) !important;
  border: 1px solid var(--color-border-subtle) !important;
  border-radius: 0.25rem; /* Or your preferred border-radius */
}
input[type="number"]:focus, input[type="text"]:focus, input[type="email"]:focus, input[type="password"]:focus, textarea:focus {
  border-color: var(--color-accent-emphasis) !important;
  box-shadow: 0 0 0 2px var(--color-accent-subtle-bg) !important; /* Focus ring */
}
/* Placeholder text color */
::placeholder {
  color: var(--color-text-muted);
  opacity: 1; /* Firefox */
}
:-ms-input-placeholder { /* Internet Explorer 10-11 */
 color: var(--color-text-muted);
}
::-ms-input-placeholder { /* Microsoft Edge */
 color: var(--color-text-muted);
}

/* ================================================================ */
/* ALL CUSTOM CLASSES DEFINED                                     */
/* ================================================================ */

/* Backgrounds */
.bg-app { background-color: var(--color-bg-app); }
.bg-surface { background-color: var(--color-bg-surface); }
.bg-surface-alt { background-color: var(--color-bg-surface-alt); }
.bg-hover { background-color: var(--color-bg-hover); }
.bg-active { background-color: var(--color-bg-active); }

/* Text */
.text-default { color: var(--color-text-default); }
.text-subtle { color: var(--color-text-subtle); }
.text-muted { color: var(--color-text-muted); }
.text-on-accent { color: var(--color-text-on-accent); }
.text-on-destructive { color: var(--color-text-on-destructive); }
.text-link { color: var(--color-text-link); }

/* Borders & Dividers - Color only */
.border-strong { border-color: var(--color-border-strong); }
.border-subtle { border-color: var(--color-border-subtle); }
.border-divider { border-color: var(--color-border-divider); }

/* Accents - For text colors */
.text-accent-emphasis { color: var(--color-accent-emphasis); }
.text-accent-destructive { color: var(--color-accent-destructive); }
.text-accent-success { color: var(--color-accent-success); }
.text-accent-warning { color: var(--color-accent-warning); }
.text-accent-info { color: var(--color-accent-info); }

/* Accents - For background colors */
.bg-accent-emphasis { background-color: var(--color-accent-emphasis); }
.bg-accent-emphasis-hover { background-color: var(--color-accent-emphasis-hover); }
.bg-accent-subtle-bg { background-color: var(--color-accent-subtle-bg); }
.bg-accent-destructive { background-color: var(--color-accent-destructive); }
.bg-accent-destructive-hover { background-color: var(--color-accent-destructive-hover); }
.bg-accent-success { background-color: var(--color-accent-success); }
.bg-accent-warning { background-color: var(--color-accent-warning); }
.bg-accent-info { background-color: var(--color-accent-info); }

/* Accents - For border colors */
.border-accent-emphasis { border-color: var(--color-accent-emphasis); }
.border-accent-destructive { border-color: var(--color-accent-destructive); }
.border-accent-success { border-color: var(--color-accent-success); }
.border-accent-warning { border-color: var(--color-accent-warning); }
.border-accent-info { border-color: var(--color-accent-info); }

/* MDC Theme On Primary Text Color */
.text-mdc-on-primary { color: var(--mdc-theme-on-primary); }


/* --- Mappings for classes used in Profile.jsx (if different from above generic names) --- */
.text-primary { color: var(--color-text-default); }    /* Maps to .text-default */
.text-secondary { color: var(--color-text-subtle); } /* Maps to .text-subtle */
.text-error { color: var(--color-accent-destructive); }     /* Maps to .text-accent-destructive */

.bg-primary { background-color: var(--color-bg-app); }      /* Maps to .bg-app */
.bg-secondary { background-color: var(--color-bg-surface); }/* Maps to .bg-surface */

.border-primary { border-color: var(--color-border-strong); }  /* Maps to .border-strong */
.border-secondary { border-color: var(--color-border-subtle); }/* Maps to .border-subtle */


select {
  appearance: none;
}


@keyframes slideInBottom {
  from {
    transform: translateY(100%);
    opacity: 0;
  }
  to {
    transform: translateY(0);
    opacity: 1;
  }
}

.animate-slide-in-bottom {
  animation: slideInBottom 0.3s ease-out forwards;
}



// src/App.tsx
// src/App.jsx
import { h } from 'preact';
// Import from preact-iso
import { useEffect } from 'preact/hooks';
import { LocationProvider, Router, Route } from 'preact-iso';

// Import Layout and Pages
import { MainLayout } from './components/layout/MainLayout';
import LogWorkout from './pages/LogWorkout';
import History from './pages/History';
import Stats from './pages/Stats';
import Profile from './pages/Profile';
import {GUI_THEME_STORAGE_KEY, AVAILABLE_THEMES  } from './pages/Profile.jsx'
// import NotFound from './pages/NotFound'; // Optional

const App = () => {
    useEffect(() => {
    if (typeof window !== 'undefined') {
      // Remove all theme-prefixed classes
      let currentGuiTheme = localStorage.getItem(GUI_THEME_STORAGE_KEY)
      if(currentGuiTheme != null) {
        AVAILABLE_THEMES.forEach(theme => document.documentElement.classList.remove(`theme-${theme.id}`));
        document.documentElement.classList.add(`theme-${currentGuiTheme}`);
      }
    }
  }, []);


  return (
    // Wrap the entire app in LocationProvider
    <LocationProvider>
      {/* MainLayout now wraps the Router to provide consistent structure */}
      <MainLayout>
        {/* Router defines the routes */}
        <Router>
          {/* Route components now render directly, MainLayout provides the frame */}
          <Route path="/" component={LogWorkout} />
          <Route path="/log" component={LogWorkout} />
          <Route path="/history" component={History} />
          <Route path="/stats" component={Stats} />
          <Route path="/profile" component={Profile} />
        </Router>
      </MainLayout>
    </LocationProvider>
  );
};

export default App;


// src/components/AddExerciseModal.jsx
// src-ui/components/AddExerciseModal.jsx
import { h } from 'preact';
import { useState, useEffect, useCallback } from 'preact/hooks';
import { invoke } from '@tauri-apps/api/core';
import { X, Loader2, AlertTriangle } from 'lucide-preact'; // Removed unused Square, CheckSquare, Edit3
import CreateExerciseModal from './CreateExerciseModal';
import ExerciseSelectionStep from './ExerciseSelectionStep';
import LogDetailsStep from './LogDetailsStep';

const EXERCISE_TYPES_CONST = { BODYWEIGHT: 'BodyWeight' };

// Helper to safely parse numeric inputs from form strings
const parseNumericInput = (value, parser) => {
    if (value == null || String(value).trim() === "") return undefined; // Empty strings become undefined
    const parsed = parser(value);
    return isNaN(parsed) ? undefined : parsed; // NaN results also become undefined
};

const AddExerciseModal = ({ 
  isOpen, 
  onClose, 
  currentDateKey, 
  onActionCompleted,
  preSelectedExercise: preSelectedExerciseProp,
  initialLogData: initialLogDataProp,
  editingWorkoutLogId
}) => {
  const [step, setStep] = useState(1);
  
  const [selectedExercise, setSelectedExercise] = useState(null);
  const [logData, setLogData] = useState({ reps: '', weight: '', duration: '', distance: '' });
  
  const [configLoading, setConfigLoading] = useState(true);
  const [userBodyweight, setUserBodyweight] = useState(null);
  const [userBodyweightUnit, setUserBodyweightUnit] = useState('kg');
  
  const [isSubmitting, setIsSubmitting] = useState(false);
  const [error, setError] = useState(null);

  const [isCreateExerciseModalOpen, setIsCreateExerciseModalOpen] = useState(false);
  const [availableMusclesForCreate, setAvailableMusclesForCreate] = useState([]);

  const isEditMode = !!editingWorkoutLogId;

  const fetchUserConfig = useCallback(async () => {
    setConfigLoading(true);
    try {
      const configData = await invoke('get_config');
      if (configData) {
        let bodyweights = await invoke("get_body_weights") 
        setUserBodyweight(bodyweights[0][2])
        if (configData.units) {
            const unitSystem = typeof configData.units === 'string' ? configData.units.toLowerCase() : (configData.units.weight || 'kg');
            setUserBodyweightUnit(unitSystem === 'imperial' ? 'lbs' : 'kg');
        }
      }
    } catch (err) {
      console.error("Modal user config fetch error:", err);
      setError(err.message || "Failed to load user configuration.");
    } finally {
      setConfigLoading(false);
    }
  }, []);

  useEffect(() => {
    if (isOpen) {
      setIsSubmitting(false);
      setError(null);
      fetchUserConfig();

      if (preSelectedExerciseProp) {
        setSelectedExercise(preSelectedExerciseProp);
        setLogData(initialLogDataProp || { reps: '', weight: '', duration: '', distance: '' });
        setStep(2);
      } else {
        setStep(1);
        setSelectedExercise(null);
        setLogData({ reps: '', weight: '', duration: '', distance: '' });
      }
    } else {
        setStep(1);
        setSelectedExercise(null);
        setLogData({ reps: '', weight: '', duration: '', distance: '' });
    }
  }, [isOpen, preSelectedExerciseProp, initialLogDataProp, editingWorkoutLogId, fetchUserConfig]);

  const handleExerciseSelectFromStep1 = useCallback(async (exerciseDef) => {
    setSelectedExercise(exerciseDef);
    // Reset logData, then try to pre-fill with previous if not "Add Set" or "Edit"
    const baseLogData = { reps: '', weight: '', duration: '', distance: '' };
    setLogData(baseLogData);
    setStep(2);
    setError(null);

    if (exerciseDef && exerciseDef.name && !initialLogDataProp) { // Not "Add Set" or "Edit"
        try {
            const previousWorkouts = await invoke('get_previous_workout_details', {
                payload: { identifier: exerciseDef.name, n: 1 }
            });
            if (previousWorkouts && previousWorkouts.length > 0) {
                const prev = previousWorkouts[0];
                const newLogData = {}; // Build from scratch to avoid stale data
                if (exerciseDef.log_reps && prev.reps != null) newLogData.reps = prev.reps.toString();
                if (exerciseDef.log_weight && prev.weight != null) newLogData.weight = prev.weight.toString();
                if (exerciseDef.log_duration && prev.duration_minutes != null) newLogData.duration = prev.duration_minutes.toString();
                if (exerciseDef.log_distance && prev.distance != null) newLogData.distance = prev.distance.toString();
                setLogData(current => ({...baseLogData, ...newLogData})); // Apply over base
            }
        } catch (err) {
            console.warn(`Could not fetch previous workout data for '${exerciseDef.name}':`, err);
        }
    }
  }, [initialLogDataProp]);

  const handleLogDataChange = useCallback((e) => {
    const { name, value } = e.target;
    // Basic validation for numeric fields can be done here if desired, or rely on parseNumericInput
    setLogData(prev => ({ ...prev, [name]: value }));
  }, []);

  const handleSubmitWorkout = async (e) => {
    e.preventDefault();
    if (!selectedExercise || !currentDateKey) return;

    let hasMetrics = false;
    if (selectedExercise.log_reps && String(logData.reps).trim()) hasMetrics = true;
    if (selectedExercise.log_weight && String(logData.weight).trim()) hasMetrics = true;
    if (selectedExercise.log_duration && String(logData.duration).trim()) hasMetrics = true;
    if (selectedExercise.log_distance && String(logData.distance).trim()) hasMetrics = true;

    if (!hasMetrics) {
        let msg = "Please enter at least one value for: ";
        if(selectedExercise.log_reps) msg += "Reps, "; if(selectedExercise.log_weight) msg += "Weight, ";
        if(selectedExercise.log_duration) msg += "Duration, "; if(selectedExercise.log_distance) msg += "Distance, ";
        setError(msg.trim().replace(/,$/, '') + "."); return;
    }

    setIsSubmitting(true); setError(null);

    try {
      if (isEditMode) {
        const editPayloadRaw = {
          id: editingWorkoutLogId,
          new_reps: selectedExercise.log_reps ? parseNumericInput(logData.reps, parseInt) : undefined,
          new_duration: selectedExercise.log_duration ? parseNumericInput(logData.duration, parseInt) : undefined,
          new_distance_arg: selectedExercise.log_distance ? parseNumericInput(logData.distance, parseFloat) : undefined,
          new_weight: undefined,
          new_bodyweight: undefined,
        };

        let weightFieldChangedInForm = false;
        if (selectedExercise.log_weight) {
            const initialWeightValueStr = String(initialLogDataProp?.weight || "");
            if (String(logData.weight) !== initialWeightValueStr) {
                weightFieldChangedInForm = true;
            }
        }
        
        if (selectedExercise.type_ === EXERCISE_TYPES_CONST.BODYWEIGHT) {
            if (weightFieldChangedInForm && selectedExercise.log_weight) { 
                if (userBodyweight != null && !isNaN(userBodyweight)) {
                    const additionalWeight = parseNumericInput(logData.weight, parseFloat) || 0;
                    editPayloadRaw.new_weight = userBodyweight + additionalWeight; 
                } else { setError("User bodyweight not configured for BW+ exercise edit."); setIsSubmitting(false); return; }
            }
        } else { 
            if (weightFieldChangedInForm && selectedExercise.log_weight) {
                 if (String(logData.weight).trim() === "") {
                    editPayloadRaw.new_weight = null; // Explicitly cleared, send null to backend Option<f64>
                } else {
                    editPayloadRaw.new_weight = parseNumericInput(logData.weight, parseFloat);
                }
            }
        }
        
        const finalEditPayload = Object.fromEntries(Object.entries(editPayloadRaw).filter(([, value]) => value !== undefined));
        
        if (Object.keys(finalEditPayload).length <= 1 && finalEditPayload.id) {
             console.warn("Edit: No changes detected to send.");
             onActionCompleted(null); onClose(); setIsSubmitting(false); return; 
        }
        await invoke('edit_workout', { params: finalEditPayload });
        onActionCompleted(null);

      } else { // ADD MODE
        const workoutDate = new Date(currentDateKey + "T12:00:00.000Z").toISOString();
        const addPayload = {
          exercise_identifier: selectedExercise.name, date: workoutDate, sets: 1, 
          reps: selectedExercise.log_reps ? parseNumericInput(logData.reps, parseInt) : undefined,
          weight: selectedExercise.log_weight ? parseNumericInput(logData.weight, parseFloat) : undefined,
          duration: selectedExercise.log_duration ? parseNumericInput(logData.duration, parseInt) : undefined,
          distance: selectedExercise.log_distance ? parseNumericInput(logData.distance, parseFloat) : undefined,
          bodyweight_to_use: undefined,
        };

        if (selectedExercise.type_ === EXERCISE_TYPES_CONST.BODYWEIGHT) {
          if (userBodyweight != null && !isNaN(userBodyweight)) {
            addPayload.bodyweight_to_use = userBodyweight;
          } else { setError("Your bodyweight is not configured."); setIsSubmitting(false); return; }
        }
        
        const [, pbInfo] = await invoke('add_workout', { params: addPayload }); 
        onActionCompleted(pbInfo);
      }
      onClose();
    } catch (err) {
      console.error(`Submit error (${isEditMode ? 'edit' : 'add'}):`, err);
      setError(err.message || `Failed to ${isEditMode ? 'save' : 'log'}.`);
    } finally { setIsSubmitting(false); }
  };

  const handleOpenCreateExerciseModal = () => setIsCreateExerciseModalOpen(true);
  
  const handleExerciseCreated = () => {
    setIsCreateExerciseModalOpen(false);
    // ExerciseSelectionStep will typically re-fetch on its own if re-mounted or a key changes.
    // For now, parent LogWorkout handles refreshing the entire view which re-opens this modal fresh.
  };
  
  const handleStep1InitialDataLoaded = useCallback((muscles) => {
    setAvailableMusclesForCreate(muscles);
  }, []);

  if (!isOpen) return null;
  
  const getEffectiveTitle = () => {
    if (step === 1) return 'Select Exercise';
    if (isEditMode) return `Edit Log: ${selectedExercise?.name || 'Details'}`;
    return `Log: ${selectedExercise?.name || 'Details'}`;
  };
  const getSubmitButtonText = () => isSubmitting ? (isEditMode ? "Saving..." : "Logging...") : (isEditMode ? "Save Changes" : "Log Workout");
  
  // Show back button if in step 2 AND it wasn't an "Add Set" or "Edit Set" direct entry.
  // This means preSelectedExerciseProp would be null if user navigated from step 1.
  const showHeaderBackButton = step === 2 && !preSelectedExerciseProp;


  return (
    <>
      <div className="fixed inset-0 bg-black/70 flex items-center justify-center p-4 z-[100] backdrop-blur-sm">
        <div className="bg-surface rounded-xl shadow-2xl w-full max-w-lg max-h-[90vh] flex flex-col overflow-hidden border border-subtle">
          <div className="flex items-center justify-between p-4 sm:p-5 border-b border-subtle bg-app">
            <h2 className="text-xl sm:text-2xl font-semibold text-default">
              <span className="flex items-center">
                {showHeaderBackButton && (
                    <button 
                        type="button" 
                        onClick={() => { 
                            setStep(1); 
                            setError(null); 
                            setSelectedExercise(null); // Clear selection when going back
                            setLogData({ reps: '', weight: '', duration: '', distance: '' }); // Reset form
                        }} 
                        className="mr-3 p-1.5 rounded-full text-subtle hover:bg-surface-alt hover:text-default transition-colors" 
                        aria-label="Back to exercise selection"
                    >
                    </button>
                )}
                {getEffectiveTitle()}
              </span>
            </h2>
            <button onClick={onClose} className="p-2 rounded-full text-muted hover:bg-surface-alt hover:text-subtle transition-colors" aria-label="Close modal"><X size={24} /></button>
          </div>

          <div className="p-4 sm:p-6 flex-grow overflow-y-auto">
            {error && (step === 2 || !selectedExercise) && ( // Show general error in step 2 or if step 1 failed critically before ExerciseSelectionStep renders its own error
                <div className="mb-4 bg-accent-destructive/10 border border-accent-destructive/30 p-3 rounded-lg text-accent-destructive flex items-start shadow-sm">
                <AlertTriangle size={20} className="mr-2 mt-0.5 text-accent-destructive flex-shrink-0" />
                <p className="text-sm">{error}</p>
                </div>
            )}

            {step === 1 && (
              <ExerciseSelectionStep
                onExerciseSelect={handleExerciseSelectFromStep1}
                onOpenCreateExerciseModal={handleOpenCreateExerciseModal}
                onInitialDataLoaded={handleStep1InitialDataLoaded} 
              />
            )}

            {step === 2 && selectedExercise && !configLoading && (
              <>
                <LogDetailsStep
                  selectedExercise={selectedExercise}
                  logData={logData}
                  onLogDataChange={handleLogDataChange}
                  userBodyweight={userBodyweight}
                  userBodyweightUnit={userBodyweightUnit}
                />
                <div className="flex items-center justify-end gap-3 pt-4 mt-3 border-t border-subtle">
                  <button 
                    type="button" 
                    onClick={() => { 
                        setStep(1); 
                        setError(null); 
                        setSelectedExercise(null);
                        setLogData({ reps: '', weight: '', duration: '', distance: '' }); 
                    }} 
                    className="px-5 py-2 text-sm font-medium text-default bg-app hover:bg-surface-alt border border-strong rounded-lg shadow-sm transition-colors"
                  >
                    Back
                  </button>
                  <button 
                    type="button" 
                    onClick={handleSubmitWorkout} 
                    disabled={isSubmitting || !selectedExercise} 
                    className="px-6 py-2.5 text-sm font-semibold text-on-accent bg-accent-emphasis hover:bg-accent-emphasis-hover rounded-lg shadow-md transition-colors disabled:opacity-60 disabled:cursor-not-allowed flex items-center justify-center min-w-[120px]"
                  >
                    {isSubmitting ? <Loader2 size={18} className="animate-spin mr-2" /> : null}
                    {getSubmitButtonText()}
                  </button>
                </div>
              </>
            )}
            {step === 2 && configLoading && ( // Show loader if config is loading for step 2
                 <div className="flex justify-center py-8"><Loader2 size={36} className="animate-spin text-accent-emphasis" /> <span className="ml-2">Loading details...</span></div>
            )}
             {step === 2 && !selectedExercise && !configLoading && ( // Fallback if somehow in step 2 without selection and not loading config
                <p className="text-center text-muted py-6">Please select an exercise first or an error occurred.</p> 
            )}
          </div>
        </div>
      </div>

      <CreateExerciseModal
        isOpen={isCreateExerciseModalOpen}
        onClose={() => setIsCreateExerciseModalOpen(false)}
        onExerciseCreated={handleExerciseCreated}
        availableMuscles={availableMusclesForCreate}
      />
    </>
  );
};

export default AddExerciseModal;


// src/components/CreateExerciseModal.jsx
// CreateExerciseModal.jsx
import { h } from 'preact';
import { useState, useEffect, useCallback } from 'preact/hooks';
import { invoke } from '@tauri-apps/api/core';
import { X, Loader2, AlertTriangle, CheckSquare, Square } from 'lucide-preact';

const EXERCISE_TYPES = [
  { value: 'Resistance', label: 'Resistance (Weights)' },
  { value: 'BodyWeight', label: 'Bodyweight' },
  { value: 'Cardio', label: 'Cardio' },
];

const CreateExerciseModal = ({ isOpen, onClose, onExerciseCreated, availableMuscles: propAvailableMuscles }) => {
  const [exerciseName, setExerciseName] = useState('');
  const [exerciseType, setExerciseType] = useState(''); // 'Resistance', 'BodyWeight', 'Cardio'
  const [musclesTargeted, setMusclesTargeted] = useState(''); // Comma-separated string
  const [logConfig, setLogConfig] = useState({
    reps: false,
    weight: false,
    duration: false,
    distance: false,
  });
  const [isSubmitting, setIsSubmitting] = useState(false);
  const [error, setError] = useState(null);
  const [successMessage, setSuccessMessage] = useState(null);

  // For muscle input suggestions (optional enhancement, simple text for now)
  // const [allMuscles, setAllMuscles] = useState([]);
  // useEffect(() => {
  //   if (propAvailableMuscles) {
  //     setAllMuscles(propAvailableMuscles);
  //   } else {
  //     invoke('list_all_muscles').then(setAllMuscles).catch(console.error);
  //   }
  // }, [propAvailableMuscles]);


  useEffect(() => {
    // Reset form when modal opens
    if (isOpen) {
      setExerciseName('');
      setExerciseType('');
      setMusclesTargeted('');
      setLogConfig({ reps: false, weight: false, duration: false, distance: false });
      setError(null);
      setSuccessMessage(null);
      setIsSubmitting(false);
    }
  }, [isOpen]);

  useEffect(() => {
    // Set default loggable metrics based on exercise type
    let newLogConfig = { reps: false, weight: false, duration: false, distance: false };
    if (exerciseType === 'BodyWeight') {
      newLogConfig.reps = true;
    } else if (exerciseType === 'Resistance') {
      newLogConfig.reps = true;
      newLogConfig.weight = true;
    } else if (exerciseType === 'Cardio') {
      newLogConfig.duration = true;
      // newLogConfig.distance = true; // Optional: enable distance for cardio by default
    }
    setLogConfig(newLogConfig);
  }, [exerciseType]);

  const handleLogConfigChange = (metric) => {
    setLogConfig(prev => ({ ...prev, [metric]: !prev[metric] }));
  };

  const handleSubmit = async (e) => {
    e.preventDefault();
    setError(null);
    setSuccessMessage(null);

    if (!exerciseName.trim()) {
      setError("Exercise name is required.");
      return;
    }
    if (!exerciseType) {
      setError("Exercise type is required.");
      return;
    }
    // Basic validation for muscles: allow empty, or non-empty must not be just commas/spaces
    const cleanedMuscles = musclesTargeted.split(',').map(m => m.trim()).filter(Boolean).join(', ');


    setIsSubmitting(true);

    const payload = {
      name: exerciseName.trim(),
      typeStr: exerciseType, 
      muscles: cleanedMuscles ? cleanedMuscles : null,
      logReps: logConfig.reps,     
      logWeight: logConfig.weight,   
      logDuration: logConfig.duration, 
      logDistance: logConfig.distance, 
    };


    try {
      const newExerciseId = await invoke('create_exercise', payload);
      setSuccessMessage(`Exercise "${payload.name}" created successfully!`); // Removed ID for simplicity
      if (onExerciseCreated) {
        onExerciseCreated(payload.name); 
      }
      setTimeout(() => {
         onClose(); 
      }, 1500);
    } catch (err) {
      console.error("Create exercise error:", err);
      setError(typeof err === 'string' ? err : (err.message || "Failed to create exercise."));
    } finally {
      setIsSubmitting(false);
    }
  };

  if (!isOpen) return null;

  return (
    <div className="fixed inset-0 bg-black/70 flex items-center justify-center p-4 z-[101] backdrop-blur-sm">
      <div className="bg-surface rounded-xl shadow-2xl w-full max-w-md max-h-[90vh] flex flex-col overflow-hidden border border-subtle">
        <div className="flex items-center justify-between p-4 sm:p-5 border-b border-subtle bg-app">
          <h2 className="text-xl sm:text-2xl font-semibold text-default">Create New Exercise</h2>
          <button
            onClick={onClose}
            className="p-2 rounded-full text-muted hover:bg-surface-alt hover:text-subtle transition-colors"
            aria-label="Close modal"
          >
            <X size={24} />
          </button>
        </div>

        <form onSubmit={handleSubmit} className="p-4 sm:p-6 flex-grow overflow-y-auto space-y-4 sm:space-y-5">
          {error && (
            <div className="mb-4 bg-accent-destructive/10 border border-accent-destructive/30 p-3 rounded-lg text-accent-destructive flex items-start shadow-sm">
              <AlertTriangle size={20} className="mr-2 mt-0.5 text-accent-destructive flex-shrink-0" />
              <p className="text-sm">{error}</p>
            </div>
          )}
          {successMessage && (
            <div className="mb-4 bg-accent-success/10 border border-accent-success/30 p-3 rounded-lg text-accent-success flex items-start shadow-sm">
              <CheckSquare size={20} className="mr-2 mt-0.5 text-accent-success flex-shrink-0" />
              <p className="text-sm">{successMessage}</p>
            </div>
          )}

          <div>
            <label htmlFor="exerciseName" className="block text-sm font-medium text-default mb-1">Exercise Name *</label>
            <input
              type="text" name="exerciseName" id="exerciseName"
              value={exerciseName} onInput={(e) => setExerciseName(e.target.value)}
              placeholder="e.g., Barbell Squat"
              required
              className="w-full p-2.5 bg-surface text-default border border-subtle rounded-lg focus:ring-2 focus:ring-accent-subtle-bg focus:border-accent-emphasis shadow-sm"
            />
          </div>

          <div>
            <label htmlFor="exerciseType" className="block text-sm font-medium text-default mb-1">Exercise Type *</label>
            <select
              name="exerciseType" id="exerciseType"
              value={exerciseType} onChange={(e) => setExerciseType(e.target.value)}
              required
              className="w-full p-2.5 bg-surface text-default border border-subtle rounded-lg focus:ring-2 focus:ring-accent-subtle-bg focus:border-accent-emphasis shadow-sm appearance-none"
            >
              <option value="" disabled className="text-muted">Select type...</option>
              {EXERCISE_TYPES.map(type => (
                <option key={type.value} value={type.value}>{type.label}</option>
              ))}
            </select>
          </div>

          <div>
            <label htmlFor="musclesTargeted" className="block text-sm font-medium text-default mb-1">
              Muscles Targeted <span className="text-xs text-muted">(comma-separated, e.g., Quads, Glutes)</span>
            </label>
            <input
              type="text" name="musclesTargeted" id="musclesTargeted"
              value={musclesTargeted} onInput={(e) => setMusclesTargeted(e.target.value)}
              placeholder="e.g., Chest, Triceps, Shoulders"
              className="w-full p-2.5 bg-surface text-default border border-subtle rounded-lg focus:ring-2 focus:ring-accent-subtle-bg focus:border-accent-emphasis shadow-sm"
            />
            {/* Optional: Display available muscles for reference or selection */}
            {/* {allMuscles.length > 0 && (
              <p className="text-xs text-muted mt-1">Available: {allMuscles.join(', ')}</p>
            )} */}
          </div>

          <div>
            <p className="block text-sm font-medium text-default mb-2">Loggable Metrics:</p>
            <div className="grid grid-cols-2 gap-x-4 gap-y-2">
              {Object.keys(logConfig).map(metric => (
                <label key={metric} className="flex items-center space-x-2 cursor-pointer p-1.5 rounded-md hover:bg-surface-alt">
                  <input
                    type="checkbox"
                    checked={logConfig[metric]}
                    onChange={() => handleLogConfigChange(metric)}
                    className="h-5 w-5 accent-[var(--color-accent-emphasis)] border-subtle rounded focus:ring-2 focus:ring-offset-1 focus:ring-offset-[var(--color-bg-surface)] focus:ring-accent-subtle-bg"
                  />
                  <span className="text-sm text-default capitalize">{metric}</span>
                </label>
              ))}
            </div>
          </div>

          <div className="flex items-center justify-end gap-3 pt-3 mt-2 border-t border-subtle">
             <button
              type="button"
              onClick={onClose}
              disabled={isSubmitting}
              className="px-5 py-2 text-sm font-medium text-default bg-app hover:bg-surface-alt border border-strong rounded-lg shadow-sm transition-colors disabled:opacity-60"
            >
              Cancel
            </button>
            <button
              type="submit"
              disabled={isSubmitting || successMessage}
              className="px-6 py-2.5 text-sm font-semibold text-on-accent bg-accent-emphasis hover:bg-accent-emphasis-hover rounded-lg shadow-md transition-colors disabled:opacity-60 disabled:cursor-not-allowed flex items-center justify-center min-w-[120px]"
            >
              {isSubmitting ? <Loader2 size={18} className="animate-spin mr-2" /> : null}
              {successMessage ? 'Created!' : 'Create Exercise'}
            </button>
          </div>
        </form>
      </div>
    </div>
  );
};

export default CreateExerciseModal;


// src/components/DatePicker.jsx
// src/components/DatePicker.jsx
import { h } from 'preact';
import { useState, useEffect, useMemo } from 'preact/hooks';
import { ChevronLeft, ChevronRight } from 'lucide-preact';

// Helper to format date to YYYY-MM-DD
const toYYYYMMDD = (date) => {
    if (!date) return null;
    const d = new Date(date);
    const year = d.getFullYear();
    const month = String(d.getMonth() + 1).padStart(2, '0');
    const day = String(d.getDate()).padStart(2, '0');
    return `${year}-${month}-${day}`;
};

const DatePicker = ({
  initialSelectedDate,
  onDateSelect,
  onClose,
  fetchHighlightedDatesForMonth,
}) => {
  const [viewDate, setViewDate] = useState(new Date(initialSelectedDate || Date.now()));
  const [localHighlightedDates, setLocalHighlightedDates] = useState(new Set());
  const [isLoadingHighlights, setIsLoadingHighlights] = useState(false);

  const currentYear = viewDate.getFullYear();
  const currentMonth = viewDate.getMonth(); // 0-indexed

  useEffect(() => {
    if (fetchHighlightedDatesForMonth) {
      setIsLoadingHighlights(true);
      fetchHighlightedDatesForMonth(currentYear, currentMonth + 1)
        .then(dates => {
          setLocalHighlightedDates(new Set(dates));
        })
        .catch(err => {
          console.error("DatePicker: Error fetching dates for highlighting", err);
          setLocalHighlightedDates(new Set());
        })
        .finally(() => {
          setIsLoadingHighlights(false);
        });
    }
  }, [currentYear, currentMonth, fetchHighlightedDatesForMonth]);


  const daysInMonth = (year, month) => new Date(year, month + 1, 0).getDate();
  const firstDayOfMonth = (year, month) => new Date(year, month, 1).getDay(); // 0 (Sun) - 6 (Sat)

  const calendarGrid = useMemo(() => {
    const numDays = daysInMonth(currentYear, currentMonth);
    const firstDay = firstDayOfMonth(currentYear, currentMonth);
    const todayYYYYMMDD = toYYYYMMDD(new Date());
    const selectedYYYYMMDD = initialSelectedDate ? toYYYYMMDD(initialSelectedDate) : null;

    const grid = [];
    let dayCounter = 1;
    for (let i = 0; i < 6; i++) {
      const week = [];
      for (let j = 0; j < 7; j++) {
        if ((i === 0 && j < firstDay) || dayCounter > numDays) {
          week.push(<td key={`empty-${i}-${j}`} className="p-1 h-10"></td>);
        } else {
          const dateValue = new Date(currentYear, currentMonth, dayCounter);
          const dateStr = toYYYYMMDD(dateValue);
          const isToday = dateStr === todayYYYYMMDD;
          const isSelected = dateStr === selectedYYYYMMDD;
          const hasWorkout = localHighlightedDates.has(dateStr);

          let cellClass = "p-1 h-10 text-sm text-center cursor-pointer rounded-full hover:bg-[var(--color-accent-subtle-bg)] transition-colors relative";
          let textClass = "text-[var(--color-text-default)]";

          if (isSelected) {
            cellClass += " bg-[var(--color-accent-emphasis)]";
            textClass = "text-[var(--color-text-on-accent)] font-semibold";
          } else if (isToday) {
            // Ring for today, using accent color for border
            cellClass += " border-2 border-[var(--color-accent-emphasis)]";
            textClass = "text-[var(--color-accent-emphasis)] font-medium";
          }
          
          let workoutIndicatorDot = null;
          if (hasWorkout) {
            if (!isSelected) {
                 workoutIndicatorDot = <span className="absolute bottom-1.5 left-1/2 transform -translate-x-1/2 w-1.5 h-1.5 bg-[var(--color-accent-success)] rounded-full"></span>;
            }
          }

          week.push(
            <td key={`day-${dayCounter}`} 
                className={cellClass}
                onClick={() => {
                  onDateSelect(dateValue);
                  if (onClose) onClose();
                }}
            >
              <span className={textClass}>{dayCounter}</span>
              {workoutIndicatorDot}
            </td>
          );
          dayCounter++;
        }
      }
      grid.push(<tr key={`week-${i}`}>{week}</tr>);
      if (dayCounter > numDays) break;
    }
    return grid;
  }, [currentYear, currentMonth, initialSelectedDate, localHighlightedDates, onDateSelect, onClose]);

  const changeMonth = (offset) => {
    const newDate = new Date(viewDate);
    newDate.setDate(1); 
    newDate.setMonth(viewDate.getMonth() + offset);
    setViewDate(newDate);
  };

  const monthNames = ["January", "February", "March", "April", "May", "June", "July", "August", "September", "October", "November", "December"];

  return (
    <div className="absolute z-30 top-full mt-2 left-1/2 transform -translate-x-1/2 bg-[var(--color-bg-surface)] p-4 rounded-lg shadow-xl border border-[var(--color-border-subtle)] w-[20rem] sm:w-[22rem]">
      <div className="flex items-center justify-between mb-3">
        <button 
          onClick={() => changeMonth(-1)} 
          className="p-2 rounded-full hover:bg-[var(--color-bg-surface-alt)] text-[var(--color-text-subtle)]"
        >
          <ChevronLeft size={20} />
        </button>
        <div className="font-semibold text-md text-[var(--color-text-default)]">
          {monthNames[currentMonth]} {currentYear}
          {isLoadingHighlights && <span className="ml-2 text-xs text-[var(--color-text-muted)]">(Loading...)</span>}
        </div>
        <button 
          onClick={() => changeMonth(1)} 
          className="p-2 rounded-full hover:bg-[var(--color-bg-surface-alt)] text-[var(--color-text-subtle)]"
        >
          <ChevronRight size={20} />
        </button>
      </div>
      <table className="w-full border-collapse table-fixed">
        <thead>
          <tr>
            {['Su', 'Mo', 'Tu', 'We', 'Th', 'Fr', 'Sa'].map(d => (
              <th key={d} className="pb-2 pt-1 text-xs text-[var(--color-text-muted)] font-medium">{d}</th>
            ))}
          </tr>
        </thead>
        <tbody>{calendarGrid}</tbody>
      </table>
      {onClose && (
          <button 
            onClick={onClose}
            className="mt-4 w-full py-2 px-4 bg-[var(--color-bg-surface-alt)] text-[var(--color-text-default)] rounded-md hover:bg-[var(--color-border-subtle)] transition-colors text-sm"
          >
            Close
          </button>
      )}
    </div>
  );
};

export default DatePicker;


// src/components/ExerciseList.tsx
// src/components/ExerciseList.tsx (Sketch)
import { FunctionalComponent } from 'preact';
import { ExerciseDefinition, ExerciseType } from '../types';
import { invoke } from '@tauri-apps/api/core';

interface ExerciseListProps {
    exercises: ExerciseDefinition[];
    onAdd: () => void;
    onEdit: (exercise: ExerciseDefinition) => void;
    onDelete: (identifier: string) => void; // Use identifier (name or ID string)
    isLoading: boolean;
    // Add filters and onFilter prop if needed
}

export const ExerciseList: FunctionalComponent<ExerciseListProps> = ({
    exercises,
    onAdd,
    onEdit,
    onDelete,
    isLoading
}) => {
    // Similar structure to WorkoutList: Title, Add Button, Table
    return (
        <div class="p-4">
            <div class="flex justify-between items-center mb-4">
                 <h2 class="text-2xl font-semibold">Exercises</h2>
                 <button class="btn-primary" onClick={onAdd}>Add Exercise</button>
            </div>

            {isLoading && !exercises.length ? (
                <p>Loading exercises...</p>
            ) : exercises.length === 0 ? (
                 <p class="text-center text-gray-500 dark:text-gray-400">No exercises defined yet.</p>
             ) : (
                <div class="overflow-x-auto bg-white dark:bg-gray-800 rounded shadow">
                     <table class="min-w-full divide-y divide-gray-200 dark:divide-gray-700">
                        {/* Table Head: Name, Type, Muscles, Logging Flags, Actions */}
                        <thead class="bg-gray-50 dark:bg-gray-700">
                             <tr>
                                 <th class="px-6 py-3 text-left text-xs font-medium text-gray-500 dark:text-gray-300 uppercase tracking-wider">Name</th>
                                 <th class="px-6 py-3 text-left text-xs font-medium text-gray-500 dark:text-gray-300 uppercase tracking-wider">Type</th>
                                 <th class="px-6 py-3 text-left text-xs font-medium text-gray-500 dark:text-gray-300 uppercase tracking-wider">Muscles</th>
                                 <th class="px-6 py-3 text-left text-xs font-medium text-gray-500 dark:text-gray-300 uppercase tracking-wider">Logs</th>
                                 <th class="px-6 py-3 text-right text-xs font-medium text-gray-500 dark:text-gray-300 uppercase tracking-wider">Actions</th>
                             </tr>
                        </thead>
                        <tbody class="divide-y divide-gray-200 dark:divide-gray-700">
                            {exercises.map((ex) => (
                                <tr key={ex.id} class="hover:bg-gray-50 dark:hover:bg-gray-700">
                                    <td class="px-6 py-4 whitespace-nowrap text-sm font-medium">{ex.name} {ex.is_alias ? `(Alias -> ${ex.alias_target})`: ''}</td>
                                    <td class="px-6 py-4 whitespace-nowrap text-sm">{ex.exercise_type}</td>
                                    <td class="px-6 py-4 whitespace-nowrap text-sm">{ex.muscles ?? '-'}</td>
                                    <td class="px-6 py-4 whitespace-nowrap text-sm space-x-1">
                                        {ex.log_weight && <span class="px-2 py-1 text-xs font-semibold rounded bg-blue-100 text-blue-800">W</span>}
                                        {ex.log_reps && <span class="px-2 py-1 text-xs font-semibold rounded bg-green-100 text-green-800">R</span>}
                                        {ex.log_duration && <span class="px-2 py-1 text-xs font-semibold rounded bg-yellow-100 text-yellow-800">T</span>}
                                        {ex.log_distance && <span class="px-2 py-1 text-xs font-semibold rounded bg-purple-100 text-purple-800">D</span>}
                                    </td>
                                     <td class="px-6 py-4 whitespace-nowrap text-right text-sm font-medium space-x-2">
                                        <button class="text-indigo-600 hover:text-indigo-900 dark:text-indigo-400 dark:hover:text-indigo-300" onClick={() => onEdit(ex)}>Edit</button>
                                        {/* Use name or ID as identifier */}
                                        <button class="text-red-600 hover:text-red-900 dark:text-red-400 dark:hover:text-red-300" onClick={() => onDelete(ex.name)}>Delete</button>
                                    </td>
                                </tr>
                            ))}
                        </tbody>
                    </table>
                </div>
            )}
        </div>
    );
};


// src/components/ExerciseSelectionStep.jsx
// src-ui/components/ExerciseSelectionStep.jsx
import { h } from 'preact';
import { useState, useEffect, useCallback } from 'preact/hooks';
import { invoke } from '@tauri-apps/api/core';
import { Loader2, AlertTriangle, Search, XCircle, PlusCircle } from 'lucide-preact';

const EXERCISE_TYPES = { BODYWEIGHT: 'BodyWeight', RESISTANCE: 'Resistance', CARDIO: 'Cardio' };
const EXERCISE_TYPE_LABELS = { [EXERCISE_TYPES.BODYWEIGHT]: 'Bodyweight', [EXERCISE_TYPES.RESISTANCE]: 'Resistance', [EXERCISE_TYPES.CARDIO]: 'Cardio' };

const ExerciseSelectionStep = ({ onExerciseSelect, onOpenCreateExerciseModal, onInitialDataLoaded }) => {
  const [searchTerm, setSearchTerm] = useState('');
  const [exercisesToDisplay, setExercisesToDisplay] = useState([]);
  const [availableMuscles, setAvailableMuscles] = useState([]);
  const [selectedMuscles, setSelectedMuscles] = useState([]);
  const [selectedExerciseType, setSelectedExerciseType] = useState(null);
  
  const [loading, setLoading] = useState(true);
  const [error, setError] = useState(null);
  const [initialExerciseCount, setInitialExerciseCount] = useState(0);

  const fetchInitialStep1Data = useCallback(async () => {
    setLoading(true);
    setError(null);
    try {
      const [musclesData, allExercisesInitial] = await Promise.all([
        invoke('list_all_muscles'),
        invoke('list_exercises', { typeFilterStr: null, muscleFilter: null }) // To get initial count and display
      ]);
      setAvailableMuscles(musclesData || []);
      const count = allExercisesInitial ? allExercisesInitial.length : 0;
      setInitialExerciseCount(count);
      
      // Initially display all exercises if count > 0, or let filter effect handle it
      if (count > 0 && !searchTerm && !selectedExerciseType && selectedMuscles.length === 0) {
        setExercisesToDisplay(allExercisesInitial || []);
      } else {
        // If filters might be active from a previous interaction (though state is reset),
        // or if count is 0, this will be handled by the fetchExercisesOnFilterChange effect.
        setExercisesToDisplay([]); // Start empty, let filter effect populate
      }
      if (onInitialDataLoaded) onInitialDataLoaded(musclesData || []);

    } catch (err) {
      console.error("Step 1 initial data fetch error:", err);
      setError(typeof err === 'string' ? err : (err.message || "Failed to load exercise data."));
      setAvailableMuscles([]);
      setInitialExerciseCount(0);
      setExercisesToDisplay([]);
    } finally {
      setLoading(false);
    }
  }, [onInitialDataLoaded]); // Added onInitialDataLoaded

  const fetchExercisesOnFilterChange = useCallback(async () => {
    // Don't fetch if initial data is still loading
    if (loading && initialExerciseCount === 0 && availableMuscles.length === 0) return;

    setLoading(true); // Loading for filter application
    setError(null);
    try {
      let fetched = await invoke('list_exercises', {
        typeFilterStr: selectedExerciseType,
        musclesFilter: selectedMuscles.length > 0 ? selectedMuscles : null,
      });
      
      if (searchTerm) {
        const lowerSearchTerm = searchTerm.toLowerCase().trim();
        if (lowerSearchTerm) {
            fetched = (fetched || []).filter(ex => ex.name.toLowerCase().includes(lowerSearchTerm));
        }
      }
      setExercisesToDisplay(fetched || []);
    } catch (err) {
      console.error("Step 1 fetch exercises error:", err);
      setError(typeof err === 'string' ? err : (err.message || "Failed to load exercises."));
      setExercisesToDisplay([]);
    } finally {
      setLoading(false);
    }
  }, [selectedExerciseType, selectedMuscles, searchTerm]); // Removed loading, initialExerciseCount, availableMuscles

  // Effect for initial data load
  useEffect(() => {
    fetchInitialStep1Data();
  }, [fetchInitialStep1Data]);

  // Effect for fetching exercises when filters or search term change
  useEffect(() => {
    // Avoid running this if fetchInitialStep1Data is still effectively loading the base set.
    // The initial fetchInitialStep1Data can populate the list directly or let this handle it.
    // For simplicity, let this always run after initial load completes, or if filters change.
    // Add a debounce for search term.
    const timeoutId = setTimeout(() => {
        // If not loading from initial fetch, then apply filters.
        // This condition is tricky. Let's simplify: if it's not the very first render,
        // or if filters are active, fetch.
        fetchExercisesOnFilterChange();
    }, searchTerm ? 300 : 0); // Debounce only for search term

    return () => clearTimeout(timeoutId);
  }, [searchTerm, selectedMuscles, selectedExerciseType, fetchExercisesOnFilterChange]);


  const handleMuscleClick = (muscle) => {
    setSelectedMuscles(prev => prev.includes(muscle) ? prev.filter(m => m !== muscle) : [...prev, muscle]);
  };

  const handleExerciseTypeClick = (type) => {
    setSelectedExerciseType(prev => (prev === type ? null : type));
  };
  
  const noFiltersActive = !searchTerm.trim() && selectedMuscles.length === 0 && !selectedExerciseType;

  return (
    <div className="space-y-4 sm:space-y-5">
      {error && (
        <div className="mb-4 bg-accent-destructive/10 border border-accent-destructive/30 p-3 rounded-lg text-accent-destructive flex items-start shadow-sm">
          <AlertTriangle size={20} className="mr-2 mt-0.5 text-accent-destructive flex-shrink-0" />
          <p className="text-sm">{error}</p>
        </div>
      )}
      <div className="flex items-center gap-2">
        <div className="relative flex-grow">
          <div className="absolute inset-y-0 left-0 pl-3 flex items-center pointer-events-none"><Search size={20} className="text-muted" /></div>
          <input type="text" placeholder="Search exercises..." value={searchTerm} onInput={(e) => setSearchTerm(e.target.value)} className="w-full pl-10 pr-10 py-2.5 bg-surface text-default border border-subtle rounded-lg focus:ring-2 focus:ring-accent-subtle-bg focus:border-accent-emphasis shadow-sm transition-shadow"/>
          {searchTerm && (<button onClick={() => setSearchTerm('')} className="absolute inset-y-0 right-0 pr-3 flex items-center text-muted hover:text-subtle" aria-label="Clear search"><XCircle size={18} /></button>)}
        </div>
        <button type="button" onClick={onOpenCreateExerciseModal} title="Create New Exercise" className="p-2.5 bg-accent-emphasis hover:bg-accent-emphasis-hover text-on-accent rounded-lg shadow-sm transition-colors flex items-center justify-center"><PlusCircle size={20} /></button>
      </div>

      <div>
        <p className="text-xs text-muted mb-2 font-medium uppercase tracking-wider">Filter by type:</p>
        <div className="flex flex-wrap gap-2">
          {Object.values(EXERCISE_TYPES).map(typeKey => (<button key={typeKey} onClick={() => handleExerciseTypeClick(typeKey)} className={`px-3.5 py-1.5 text-sm rounded-full border-2 transition-all duration-150 ease-in-out font-medium ${selectedExerciseType === typeKey ? 'bg-accent-emphasis text-on-accent border-accent-emphasis shadow-md hover:bg-accent-emphasis-hover' : 'bg-app text-default border-strong hover:border-accent-emphasis hover:text-accent-emphasis'}`}>{EXERCISE_TYPE_LABELS[typeKey]}</button>))}
          {selectedExerciseType && (<button onClick={() => setSelectedExerciseType(null)} className="px-3 py-1.5 text-sm rounded-full border-2 border-strong bg-surface-alt text-muted hover:bg-active hover:border-strong flex items-center gap-1" title="Clear type filter"><XCircle size={14} /> Clear Type</button>)}
        </div>
      </div>

      {availableMuscles.length > 0 && (<div>
          <p className="text-xs text-muted mb-2 font-medium uppercase tracking-wider">Filter by muscle group:</p>
          <div className="flex flex-wrap gap-2">
            {availableMuscles.map(muscle => (<button key={muscle} onClick={() => handleMuscleClick(muscle)} className={`px-3.5 py-1.5 text-sm rounded-full border-2 transition-all duration-150 ease-in-out font-medium ${selectedMuscles.includes(muscle) ? 'bg-accent-emphasis text-on-accent border-accent-emphasis shadow-md hover:bg-accent-emphasis-hover' : 'bg-app text-default border-strong hover:border-accent-emphasis hover:text-accent-emphasis'}`}>{muscle}</button>))}
            {selectedMuscles.length > 0 && (<button onClick={() => setSelectedMuscles([])} className="px-3 py-1.5 text-sm rounded-full border-2 border-strong bg-surface-alt text-muted hover:bg-active hover:border-strong flex items-center gap-1" title="Clear all muscle filters"><XCircle size={14} /> Clear Muscles</button>)}
          </div>
      </div>)}

      {loading && <div className="flex justify-center py-8"><Loader2 size={36} className="animate-spin text-accent-emphasis" /></div>}
      
      {!loading && exercisesToDisplay.length > 0 && (<div className="max-h-[calc(90vh-380px)] sm:max-h-[calc(90vh-360px)] overflow-y-auto space-y-2 pr-1 -mr-1 mt-3">
          {exercisesToDisplay.map(exercise => (<button key={exercise.id || exercise.name} onClick={() => onExerciseSelect(exercise)} className="w-full text-left p-3.5 bg-app hover:bg-accent-subtle-bg border border-subtle rounded-lg shadow-sm transition-all duration-150 ease-in-out focus:outline-none focus:ring-2 focus:ring-accent-emphasis/50 focus:border-accent-emphasis">
              <p className="font-semibold text-default text-md">{exercise.name}</p>
              {exercise.muscles && typeof exercise.muscles === 'string' && (<p className="text-xs text-accent-emphasis font-medium mt-0.5">{exercise.muscles}</p>)}
              {exercise.type_ && <p className="text-xs text-muted mt-0.5">Type: {EXERCISE_TYPE_LABELS[exercise.type_] || exercise.type_}</p>}
          </button>))}
      </div>)}
      
      {!loading && exercisesToDisplay.length === 0 && ( noFiltersActive ? ( initialExerciseCount === 0 ? (<p className="text-center text-muted py-6">No exercises defined yet. Try creating one!</p>) : (<p className="text-center text-muted py-6">Search or apply filters to see results.</p>) ) : (<p className="text-center text-muted py-6">No exercises found matching your criteria.</p>) )}
    </div>
  );
};

export default ExerciseSelectionStep;


// src/components/LogDetailsStep.jsx
// src-ui/components/LogDetailsStep.jsx
import { h } from 'preact';

const EXERCISE_TYPES = { BODYWEIGHT: 'BodyWeight' }; // Only need BODYWEIGHT for the check here

const LogDetailsStep = ({
  selectedExercise, // The ExerciseDefinition object
  logData,          // Object: { reps, weight, duration, distance }
  onLogDataChange,  // Function to update logData in parent
  userBodyweight,
  userBodyweightUnit,
  // isEditMode, // Not directly used in this component's rendering for now, but could be
}) => {
  if (!selectedExercise) return <p>Error: No exercise selected for logging.</p>;

  return (
    <form className="space-y-4 sm:space-y-5"> {/* Form tag is for semantics, submit handled by parent */}
      {selectedExercise.type_ === EXERCISE_TYPES.BODYWEIGHT && (
        <div className="mb-1 p-2.5 bg-accent-subtle-bg border border-accent-emphasis/30 rounded-lg text-sm text-accent-emphasis shadow-sm">
          This is a bodyweight exercise.
          {userBodyweight != null ? ` Your configured bodyweight (${userBodyweight} ${userBodyweightUnit}) will be used.` : " Your bodyweight is not configured. Please set it in your profile/settings to log this exercise accurately."}
        </div>
      )}

      {selectedExercise.log_reps && (
        <div>
          <label htmlFor="reps" className="block text-sm font-medium text-default mb-1">Reps</label>
          <input type="number" name="reps" id="reps" value={logData.reps} onInput={onLogDataChange} placeholder="e.g., 10" min="0" className="w-full p-2.5 bg-surface text-default border border-subtle rounded-lg focus:ring-2 focus:ring-accent-subtle-bg focus:border-accent-emphasis shadow-sm" />
        </div>
      )}
      {selectedExercise.log_weight && (
        <div>
          <label htmlFor="weight" className="block text-sm font-medium text-default mb-1">Weight <span className="text-xs text-muted">(e.g., {userBodyweightUnit || 'units'})</span></label>
          <input type="number" name="weight" id="weight" value={logData.weight} onInput={onLogDataChange} placeholder="e.g., 50.5" step="0.1" min="0" className="w-full p-2.5 bg-surface text-default border border-subtle rounded-lg focus:ring-2 focus:ring-accent-subtle-bg focus:border-accent-emphasis shadow-sm" />
        </div>
      )}
      {selectedExercise.log_duration && (
        <div>
          <label htmlFor="duration" className="block text-sm font-medium text-default mb-1">Duration <span className="text-xs text-muted">(minutes)</span></label>
          <input type="number" name="duration" id="duration" value={logData.duration} onInput={onLogDataChange} placeholder="e.g., 30" min="0" className="w-full p-2.5 bg-surface text-default border border-subtle rounded-lg focus:ring-2 focus:ring-accent-subtle-bg focus:border-accent-emphasis shadow-sm" />
        </div>
      )}
      {selectedExercise.log_distance && (
        <div>
          <label htmlFor="distance" className="block text-sm font-medium text-default mb-1">Distance <span className="text-xs text-muted">(e.g., {userBodyweightUnit === 'lbs' ? 'miles' : 'km'})</span></label>
          <input type="number" name="distance" id="distance" value={logData.distance} onInput={onLogDataChange} placeholder="e.g., 5.2" step="0.01" min="0" className="w-full p-2.5 bg-surface text-default border border-subtle rounded-lg focus:ring-2 focus:ring-accent-subtle-bg focus:border-accent-emphasis shadow-sm" />
        </div>
      )}
      {/* Submit/Back buttons will be in the parent AddExerciseModal */}
    </form>
  );
};

export default LogDetailsStep;


// src/components/NavBar.tsx
// src/components/NavBar.tsx
import { FunctionalComponent } from 'preact';

export type View = 'workouts' | 'exercises' | 'settings';

interface NavBarProps {
    currentView: View;
    onNavigate: (view: View) => void;
}

export const NavBar: FunctionalComponent<NavBarProps> = ({ currentView, onNavigate }) => {
    const navItemClass = (view: View) =>
        `px-4 py-2 rounded cursor-pointer transition-colors ${
            currentView === view
                ? 'bg-blue-600 text-white'
                : 'text-blue-100 hover:bg-blue-700 hover:text-white'
        }`;

    return (
        <nav class="bg-blue-800 text-white p-4 flex space-x-4 items-center shadow-md">
            <h1 class="text-xl font-bold mr-6">Workout Tracker</h1>
            <button class={navItemClass('workouts')} onClick={() => onNavigate('workouts')}>
                Workouts
            </button>
            <button class={navItemClass('exercises')} onClick={() => onNavigate('exercises')}>
                Exercises
            </button>
            {/* <button class={navItemClass('settings')} onClick={() => onNavigate('settings')}>
                Settings
            </button> */}
             {/* Add more nav items as needed */}
        </nav>
    );
};


// src/components/WorkoutForm.tsx
// src/components/WorkoutForm.tsx
import { FunctionalComponent } from 'preact';
import { useState, useEffect, useCallback } from 'preact/hooks';
import { Workout, ExerciseDefinition, AddWorkoutParams, EditWorkoutParams, ExerciseType } from '../types';
import { invoke } from '@tauri-apps/api/core';

interface WorkoutFormProps {
    exercises: ExerciseDefinition[];
    initialData?: Workout | null; // For editing
    onSubmit: (data: AddWorkoutParams | EditWorkoutParams) => Promise<void>; // Make async for loading state
    onCancel: () => void;
}

export const WorkoutForm: FunctionalComponent<WorkoutFormProps> = ({
    exercises,
    initialData,
    onSubmit,
    onCancel,
}) => {
    const [formData, setFormData] = useState<Partial<AddWorkoutParams & { id?: number; dateInput: string }>>({});
    const [selectedExercise, setSelectedExercise] = useState<ExerciseDefinition | null>(null);
    const [isLoading, setIsLoading] = useState(false);
    const [error, setError] = useState<string | null>(null);

    // Helper to format date for input type="datetime-local"
    const formatDateTimeLocal = (isoString?: string): string => {
        if (!isoString) return '';
        try {
            const date = new Date(isoString);
            // Adjust for timezone offset to display correctly in local time in the input
             const tzoffset = date.getTimezoneOffset() * 60000; //offset in milliseconds
             const localISOTime = (new Date(date.getTime() - tzoffset)).toISOString().slice(0, 16);
            return localISOTime;
        } catch {
            return ''; // Handle invalid date string if necessary
        }
    };

     // Helper to get today's date formatted for input type="date"
     const getTodayDateString = () => {
        const today = new Date();
        const year = today.getFullYear();
        const month = (today.getMonth() + 1).toString().padStart(2, '0');
        const day = today.getDate().toString().padStart(2, '0');
        return `${year}-${month}-${day}`;
    }

    useEffect(() => {
        if (initialData) {
            // Editing existing workout
            const exercise = exercises.find(ex => ex.name === initialData.exercise_name) ?? null; // Or match by ID if available and stable
             setSelectedExercise(exercise);
            setFormData({
                id: initialData.id,
                exercise_identifier: initialData.exercise_name, // Use name as identifier for simplicity here
                dateInput: formatDateTimeLocal(initialData.date), // Use helper for input
                sets: initialData.sets ?? undefined,
                reps: initialData.reps ?? undefined,
                weight: initialData.weight ?? undefined,
                duration: initialData.duration ?? undefined,
                distance: initialData.distance ?? undefined,
                notes: initialData.notes ?? undefined,
                bodyweight_to_use: initialData.bodyweight ?? undefined, // Assuming this maps to bodyweight_to_use on add/edit
                 // If editing, we likely don't need implicit types/muscles
            });
        } else {
             // Adding new workout - default date to now
             const now = new Date();
             setFormData({ dateInput: formatDateTimeLocal(now.toISOString()) });
             setSelectedExercise(null);
        }
    }, [initialData, exercises]);

    const handleInputChange = (e: Event) => {
        const { name, value, type } = e.target as HTMLInputElement;
         let processedValue: string | number | undefined = value;

         if (type === 'number' && value !== '') {
             processedValue = parseFloat(value);
             if (isNaN(processedValue)) {
                 processedValue = undefined; // Handle invalid number input
             }
         } else if (value === '') {
              processedValue = undefined; // Treat empty strings as undefined for optional fields
         }


        setFormData((prev) => ({ ...prev, [name]: processedValue }));
    };

    const handleExerciseChange = (e: Event) => {
        const exId = (e.target as HTMLSelectElement).value;
        const exercise = exercises.find(ex => ex.id.toString() === exId) ?? null;
        setSelectedExercise(exercise);
        setFormData(prev => ({ ...prev, exercise_identifier: exercise?.name })); // Use name for now
    };

     // Handle date change for datetime-local input
     const handleDateTimeChange = (e: Event) => {
        const value = (e.target as HTMLInputElement).value;
        setFormData((prev) => ({ ...prev, dateInput: value }));
    };

    const handleSubmit = async (e: Event) => {
        e.preventDefault();
        setError(null);

        if (!formData.exercise_identifier) {
            setError("Please select an exercise.");
            return;
        }

         // Convert local datetime input back to ISO string (UTC) for backend
         let isoDateString: string | undefined = undefined;
         if (formData.dateInput) {
            try {
                // Input value is local time, convert to Date object, then to UTC ISO string
                isoDateString = new Date(formData.dateInput).toISOString();
            } catch {
                 setError("Invalid date/time format.");
                 return;
            }
         }


        const dataToSend: AddWorkoutParams | EditWorkoutParams = initialData
            ? { // Edit Params (match EditWorkoutCmdParams, EditWorkoutParams TS type)
                id: formData.id!,
                new_exercise_identifier: formData.exercise_identifier,
                new_sets: formData.sets,
                new_reps: formData.reps,
                new_weight: formData.weight,
                // new_bodyweight: ??? // How to edit this? Add form field if needed
                new_duration: formData.duration,
                new_distance_arg: formData.distance, // Note name difference
                new_notes: formData.notes,
                new_date: isoDateString ? new Date(isoDateString).toISOString().split('T')[0] : undefined, // Requires YYYY-MM-DD for edit
            }
            : { // Add Params (match AddWorkoutCmdParams, AddWorkoutParams TS type)
                exercise_identifier: formData.exercise_identifier!,
                date: isoDateString, // Send UTC ISO string
                sets: formData.sets,
                reps: formData.reps,
                weight: formData.weight,
                duration: formData.duration,
                distance: formData.distance,
                notes: formData.notes,
                // implicit_type/muscles only needed if exercise doesn't exist? Backend handles this.
                bodyweight_to_use: formData.bodyweight_to_use, // Optional field
            };

        setIsLoading(true);
        try {
            await onSubmit(dataToSend);
        } catch (err: any) {
             setError(err?.message || 'Failed to save workout.');
        } finally {
            setIsLoading(false);
        }
    };

    // Determine which fields to show based on selected exercise
    const showWeight = selectedExercise?.log_weight ?? true; // Default to true if no exercise selected yet
    const showReps = selectedExercise?.log_reps ?? true;
    const showSets = selectedExercise?.log_reps ?? true; // Often linked to reps
    const showDuration = selectedExercise?.log_duration ?? false;
    const showDistance = selectedExercise?.log_distance ?? false;

    return (
        <div class="p-6 max-w-lg mx-auto bg-white dark:bg-gray-800 rounded-lg shadow-md">
            <h2 class="text-2xl font-semibold mb-6 text-center">
                {initialData ? 'Edit Workout' : 'Add New Workout'}
            </h2>
            {error && <p class="mb-4 text-red-500 bg-red-100 dark:bg-red-900 dark:text-red-200 p-3 rounded">{error}</p>}
            <form onSubmit={handleSubmit} class="space-y-4">
                <div>
                    <label for="exercise_identifier" class="input-label">Exercise</label>
                    <select
                        id="exercise_identifier"
                        name="exercise_identifier"
                        class="input-field"
                        value={selectedExercise?.id ?? ''}
                        onChange={handleExerciseChange}
                        required
                        disabled={isLoading}
                    >
                        <option value="" disabled>Select an exercise</option>
                        {exercises.map((ex) => (
                            <option key={ex.id} value={ex.id}>{ex.name}</option>
                        ))}
                    </select>
                </div>

                 <div>
                    <label for="date" class="input-label">Date & Time</label>
                    <input
                        id="date"
                        name="dateInput" // Use separate state for input value
                        type="datetime-local"
                        class="input-field"
                        value={formData.dateInput}
                        onChange={handleDateTimeChange}
                        required
                        disabled={isLoading}
                    />
                </div>

                {/* Conditionally Render Fields based on Exercise Type */}
                <div class="grid grid-cols-2 gap-4">
                    {showSets && (
                         <div>
                            <label for="sets" class="input-label">Sets</label>
                            <input id="sets" name="sets" type="number" min="0" step="1" class="input-field" value={formData.sets ?? ''} onChange={handleInputChange} disabled={isLoading} />
                         </div>
                     )}
                     {showReps && (
                         <div>
                            <label for="reps" class="input-label">Reps</label>
                            <input id="reps" name="reps" type="number" min="0" step="1" class="input-field" value={formData.reps ?? ''} onChange={handleInputChange} disabled={isLoading} />
                         </div>
                     )}
                     {showWeight && (
                         <div>
                            <label for="weight" class="input-label">Weight</label>
                            <input id="weight" name="weight" type="number" min="0" step="any" class="input-field" value={formData.weight ?? ''} onChange={handleInputChange} disabled={isLoading} />
                         </div>
                     )}
                      {showDuration && (
                         <div>
                            <label for="duration" class="input-label">Duration (s)</label>
                            <input id="duration" name="duration" type="number" min="0" step="1" class="input-field" value={formData.duration ?? ''} onChange={handleInputChange} disabled={isLoading} />
                         </div>
                     )}
                      {showDistance && (
                         <div>
                            <label for="distance" class="input-label">Distance</label>
                            <input id="distance" name="distance" type="number" min="0" step="any" class="input-field" value={formData.distance ?? ''} onChange={handleInputChange} disabled={isLoading} />
                         </div>
                     )}
                     <div>
                        <label for="bodyweight_to_use" class="input-label">Bodyweight Used (Optional)</label>
                        <input id="bodyweight_to_use" name="bodyweight_to_use" type="number" min="0" step="any" class="input-field" value={formData.bodyweight_to_use ?? ''} onChange={handleInputChange} disabled={isLoading} />
                     </div>
                </div>

                <div>
                    <label for="notes" class="input-label">Notes</label>
                    <textarea id="notes" name="notes" rows={3} class="input-field" value={formData.notes ?? ''} onChange={handleInputChange} disabled={isLoading}></textarea>
                </div>

                <div class="flex justify-end space-x-3 pt-4">
                    <button type="button" class="btn-secondary" onClick={onCancel} disabled={isLoading}>
                        Cancel
                    </button>
                    <button type="submit" class="btn-primary" disabled={isLoading}>
                        {isLoading ? 'Saving...' : (initialData ? 'Update Workout' : 'Add Workout')}
                    </button>
                </div>
            </form>
        </div>
    );
};


// src/components/WorkoutList.tsx
// src/components/WorkoutList.tsx
import { FunctionalComponent } from 'preact';
import { Workout, WorkoutFiltersParams } from '../types';
import { useState } from 'preact/hooks';
import { invoke } from '@tauri-apps/api/core';

interface WorkoutListProps {
    workouts: Workout[];
    exercises: { id: number; name: string }[]; // For filter dropdown
    onEdit: (workout: Workout) => void;
    onDelete: (id: number) => void;
    onAdd: () => void;
    onFilter: (filters: WorkoutFiltersParams) => void; // Function to trigger refetch with filters
    isLoading: boolean;
}

export const WorkoutList: FunctionalComponent<WorkoutListProps> = ({
    workouts,
    exercises,
    onEdit,
    onDelete,
    onAdd,
    onFilter,
    isLoading,
}) => {
    const [exerciseFilter, setExerciseFilter] = useState<string>('');
    const [dateFilter, setDateFilter] = useState<string>(''); // YYYY-MM-DD

    const handleFilter = () => {
        onFilter({
            exercise_name: exerciseFilter || undefined,
            date: dateFilter || undefined,
            // Add other filters if needed
        });
    };

    const formatDate = (isoDateTime: string) => {
        if (!isoDateTime) return 'N/A';
        try {
            return new Date(isoDateTime).toLocaleDateString();
        } catch (e) {
            return 'Invalid Date';
        }
    };

    return (
        <div class="p-4">
            <h2 class="text-2xl font-semibold mb-4">Workout Log</h2>

            {/* Filter Section */}
            <div class="mb-4 p-4 bg-white dark:bg-gray-800 rounded shadow flex flex-wrap gap-4 items-end">
                <div>
                    <label class="input-label" for="exercise-filter">Exercise</label>
                    <select
                        id="exercise-filter"
                        class="input-field"
                        value={exerciseFilter}
                        onChange={(e) => setExerciseFilter((e.target as HTMLSelectElement).value)}
                    >
                        <option value="">All Exercises</option>
                        {exercises.map((ex) => (
                            <option key={ex.id} value={ex.name}>{ex.name}</option>
                        ))}
                    </select>
                </div>
                 <div>
                    <label class="input-label" for="date-filter">Date</label>
                    <input
                        id="date-filter"
                        type="date"
                        class="input-field"
                        value={dateFilter}
                        onChange={(e) => setDateFilter((e.target as HTMLInputElement).value)}
                    />
                </div>
                <button class="btn-secondary" onClick={handleFilter} disabled={isLoading}>
                    {isLoading ? 'Filtering...' : 'Apply Filters'}
                </button>
                <button class="btn-secondary" onClick={() => { setExerciseFilter(''); setDateFilter(''); onFilter({});}} disabled={isLoading}>
                    Clear Filters
                </button>
                 <button class="btn-primary ml-auto" onClick={onAdd}>
                    Add Workout
                </button>
            </div>

            {/* Workout Table */}
            {isLoading && !workouts.length ? (
                <p>Loading workouts...</p>
            ) : workouts.length === 0 ? (
                <p class="text-center text-gray-500 dark:text-gray-400">No workouts found matching the criteria.</p>
            ) : (
                <div class="overflow-x-auto bg-white dark:bg-gray-800 rounded shadow">
                    <table class="min-w-full divide-y divide-gray-200 dark:divide-gray-700">
                        <thead class="bg-gray-50 dark:bg-gray-700">
                            <tr>
                                <th class="px-6 py-3 text-left text-xs font-medium text-gray-500 dark:text-gray-300 uppercase tracking-wider">Date</th>
                                <th class="px-6 py-3 text-left text-xs font-medium text-gray-500 dark:text-gray-300 uppercase tracking-wider">Exercise</th>
                                <th class="px-6 py-3 text-left text-xs font-medium text-gray-500 dark:text-gray-300 uppercase tracking-wider">Details</th>
                                <th class="px-6 py-3 text-left text-xs font-medium text-gray-500 dark:text-gray-300 uppercase tracking-wider">Notes</th>
                                <th class="px-6 py-3 text-right text-xs font-medium text-gray-500 dark:text-gray-300 uppercase tracking-wider">Actions</th>
                            </tr>
                        </thead>
                        <tbody class="divide-y divide-gray-200 dark:divide-gray-700">
                            {workouts.map((w) => (
                                <tr key={w.id} class="hover:bg-gray-50 dark:hover:bg-gray-700">
                                    <td class="px-6 py-4 whitespace-nowrap text-sm">{formatDate(w.date)}</td>
                                    <td class="px-6 py-4 whitespace-nowrap text-sm font-medium">{w.exercise_name}</td>
                                    <td class="px-6 py-4 whitespace-nowrap text-sm">
                                        {w.sets && w.reps ? `${w.sets}x${w.reps}` : ''}
                                        {w.weight ? ` @ ${w.weight} ${w.bodyweight ? '(BW: '+w.bodyweight+')' : ''}` : ''}
                                        {w.duration ? ` ${w.duration}s` : ''}
                                        {w.distance ? ` ${w.distance} units` : ''} {/* Add units from config later */}
                                    </td>
                                     <td class="px-6 py-4 text-sm max-w-xs truncate" title={w.notes ?? ''}>{w.notes ?? '-'}</td>
                                    <td class="px-6 py-4 whitespace-nowrap text-right text-sm font-medium space-x-2">
                                        <button class="text-indigo-600 hover:text-indigo-900 dark:text-indigo-400 dark:hover:text-indigo-300" onClick={() => onEdit(w)}>Edit</button>
                                        <button class="text-red-600 hover:text-red-900 dark:text-red-400 dark:hover:text-red-300" onClick={() => onDelete(w.id)}>Delete</button>
                                    </td>
                                </tr>
                            ))}
                        </tbody>
                    </table>
                </div>
            )}
        </div>
    );
};


// src/components/WorkoutLoggerView.tsx
import { h, Fragment } from 'preact';
import { CalendarIcon, PlusIcon } from './icons';

const WorkoutLoggerView = () => {
  return (
    <div class="min-h-screen bg-gray-50 py-10 px-4">
      <div class="max-w-xl mx-auto space-y-6">

        {/* Header Buttons */}
        <div class="flex justify-end space-x-3">
          <button class="flex items-center px-4 py-2 bg-white text-gray-700 rounded-lg shadow-sm hover:bg-gray-100 transition">
            <CalendarIcon class="w-5 h-5 mr-2" />
            <span class="text-sm font-medium">Calendar</span>
          </button>
          <button class="flex items-center px-4 py-2 bg-blue-600 text-white rounded-lg shadow hover:bg-blue-700 transition">
            <PlusIcon class="w-5 h-5 mr-2" />
            <span class="text-sm font-medium">Add</span>
          </button>
        </div>

        {/* Date Navigation */}
        <div class="flex items-center justify-between bg-white rounded-lg shadow py-3 px-5 border">
          <button class="text-xl text-gray-500 hover:text-blue-600 transition">&larr;</button>
          <h2 class="text-base font-semibold text-gray-800">Sunday, May 4, 2025</h2>
          <button class="text-xl text-gray-500 hover:text-blue-600 transition">&rarr;</button>
        </div>

        {/* Workout Card */}
        <div class="bg-white p-6 max-w-md rounded-lg shadow border border-gray-200">
          <h3 class="text-lg font-semibold text-gray-800 mb-4 text-center">Bench Press</h3>
          <div class="space-y-3">
            {[
              { reps: 10, weight: 135 },
              { reps: 8, weight: 155 },
              { reps: 6, weight: 175 }
            ].map((set, idx) => (
              <div
                key={idx}
                class="flex items-center px-4 py-3 bg-gray-50 rounded-lg border border-gray-100"
              >
                <div class="flex-none w-8 h-8 bg-blue-100 text-blue-600 rounded-full flex items-center justify-center font-semibold mr-4">
                  {idx + 1}
                </div>
                <div class="flex justify-between w-full text-sm font-medium text-gray-700">
                  <span>{set.reps} reps</span>
                  <span>{set.weight} lbs</span>
                </div>
              </div>
            ))}
          </div>
        </div>

      </div>
    </div>
  );
};

export default WorkoutLoggerView;



// src/components/common/BottomNav.jsx
// src/components/common/BottomNav.jsx
import { h } from 'preact';
// NO Link import needed from preact-iso
import { LineChart, ListChecks, Timer, User } from 'lucide-preact';
import classNames from 'classnames';

export const BottomNav = ({ currentPath, class: className }) => {
  const navItems = [
    { path: '/log', label: 'Log', icon: Timer },
    { path: '/history', label: 'History', icon: ListChecks },
    { path: '/stats', label: 'Stats', icon: LineChart },
    { path: '/profile', label: 'Profile', icon: User },
  ];

  const getLinkClass = (path) => classNames(
     'flex flex-col items-center justify-center flex-grow pt-2 pb-1 text-xs transition-colors duration-150',
    {
      'text-primary': currentPath === path || (path === '/log' && currentPath === '/'),
      'text-secondary hover:text-gray-800': currentPath !== path && !(path === '/log' && currentPath === '/'),
    }
  );

  const iconClass = "w-6 h-6 mb-1";

  return (
    <nav class={classNames(
      "fixed bottom-0 left-0 right-0 h-16 bg-primary border-t border-gray-200 flex items-stretch justify-around z-50",
      className
    )}>
      {navItems.map(item => (
        // Use standard <a> tag
        <a key={item.path} href={item.path} class={getLinkClass(item.path)}>
          <item.icon class={iconClass} strokeWidth={2} />
          <span>{item.label}</span>
        </a>
      ))}
    </nav>
  );
};


// src/components/common/SidebarNav.jsx
// src/components/common/SidebarNav.jsx
import { h } from 'preact';
// NO Link import needed from preact-iso
import { LineChart, ListChecks, Timer, User, LogOut } from 'lucide-preact';
import classNames from 'classnames';


export const SidebarNav = ({ currentPath, class: className }) => {
  const navItems = [
    { path: '/log', label: 'Log Workout', icon: Timer },
    { path: '/history', label: 'History', icon: ListChecks },
    { path: '/stats', label: 'Stats', icon: LineChart },
    { path: '/profile', label: 'Profile', icon: User },
  ];

  const getLinkClass = (path) => classNames(
    'flex items-center w-full px-4 py-3 text-left text-sm rounded-md hover:bg-gray-200 transition-colors duration-150',
    {
      'bg-primary/10 text-primary font-semibold': currentPath === path || (path === '/log' && currentPath === '/'),
      'text-secondary': currentPath !== path && !(path === '/log' && currentPath === '/'),
    }
  );

  const iconClass = "w-5 h-5 mr-3 flex-shrink-0";

  return (
    <aside class={classNames("w-64 bg-bg-light flex-shrink-0 p-4 flex flex-col border-r border-gray-200", className)}>
       {/* ... (Profile header) ... */}

      <nav class="flex-grow space-y-2">
        {navItems.map(item => (
          // Use standard <a> tag
          <a key={item.path} href={item.path} class={getLinkClass(item.path)}>
            <item.icon class={iconClass} strokeWidth={2} />
            <span>{item.label}</span>
          </a>
        ))}
      </nav>

      {/* ... (Logout Button) ... */}
    </aside>
  );
};


// src/components/icons.tsx
import { h } from 'preact';


// Modified icon components with viewport preservation
const IconProps = ({ className = "w-6 h-6" }) => ({
  className,
  fill: "none",
  stroke: "currentColor",
  xmlns: "http://www.w3.org/2000/svg",
  viewBox: "0 0 24 24",
  // Adding preserveAspectRatio to prevent scaling issues
  preserveAspectRatio: "xMidYMid meet",
  // Adding explicit width and height in pixels instead of relying on classes only
  width: "24",
  height: "24",
  style: { 
    // Disable any browser-specific scaling
    transform: 'none',
    transition: 'none',
    // Force rendering as a block element
    display: 'block'
  }
});

export const CalendarIcon = ({ className = "w-6 h-6" }) => (
  <svg {...IconProps({ className })}>
    <path 
      strokeLinecap="round" 
      strokeLinejoin="round" 
      strokeWidth="2" 
      d="M8 7V3m8 4V3m-9 8h10M5 21h14a2 2 0 002-2V7a2 2 0 00-2-2H5a2 2 0 00-2 2v12a2 2 0 002 2z" 
    />
  </svg>
);

export const PlusIcon = ({ className = "w-6 h-6" }) => (
  <svg {...IconProps({ className })}>
    <path 
      strokeLinecap="round" 
      strokeLinejoin="round" 
      strokeWidth="2" 
      d="M12 4v16m8-8H4" 
    />
  </svg>
);


export const ChevronLeftIcon = ({ class: className = "w-6 h-6" }: IconProps) => (
  <svg 
    xmlns="http://www.w3.org/2000/svg" 
    class={className} 
    fill="none" 
    viewBox="0 0 24 24" 
    stroke="currentColor"
  >
    <path 
      stroke-linecap="round" 
      stroke-linejoin="round" 
      stroke-width="2" 
      d="M10 19l-7-7m0 0l7-7m-7 7h18" 
    />
  </svg>
);

export const ChevronRightIcon = ({ class: className = "w-6 h-6" }: IconProps) => (
  <svg 
    xmlns="http://www.w3.org/2000/svg" 
    class={className} 
    fill="none" 
    viewBox="0 0 24 24" 
    stroke="currentColor"
  >
    <path 
      stroke-linecap="round" 
      stroke-linejoin="round" 
      stroke-width="2" 
      d="M14 5l7 7m0 0l-7 7m7-7H3" 
    />
  </svg>
);

export const EditIcon = ({ class: className = "w-6 h-6" }: IconProps) => (
  <svg 
    xmlns="http://www.w3.org/2000/svg" 
    class={className} 
    fill="none" 
    viewBox="0 0 24 24" 
    stroke="currentColor"
  >
    <path 
      stroke-linecap="round" 
      stroke-linejoin="round" 
      stroke-width="2" 
      d="M11 5H6a2 2 0 00-2 2v11a2 2 0 002 2h11a2 2 0 002-2v-5m-1.414-9.414a2 2 0 112.828 2.828L11.828 15H9v-2.828l8.586-8.586z" 
    />
  </svg>
);

export const TrashIcon = ({ class: className = "w-6 h-6" }: IconProps) => (
  <svg 
    xmlns="http://www.w3.org/2000/svg" 
    class={className} 
    fill="none" 
    viewBox="0 0 24 24" 
    stroke="currentColor"
  >
    <path 
      stroke-linecap="round" 
      stroke-linejoin="round" 
      stroke-width="2" 
      d="M19 7l-.867 12.142A2 2 0 0116.138 21H7.862a2 2 0 01-1.995-1.858L5 7m5 4v6m4-6v6m1-10V4a1 1 0 00-1-1h-4a1 1 0 00-1 1v3M4 7h16" 
    />
  </svg>
);


// src/components/layout/MainLayout.jsx
// src/components/layout/MainLayout.jsx
import { h, Fragment } from 'preact'; // Use Fragment if needed
import { useLocation } from 'preact-iso'; // Import the hook
import { SidebarNav } from '../common/SidebarNav';
import { BottomNav } from '../common/BottomNav';
// import { AppHeader } from '../common/AppHeader'; // Keep if using

// MainLayout is now a standard component receiving children
export const MainLayout = ({ children }) => {
  // Get location object using the hook
  const { path } = useLocation(); // Use 'url' or 'path' depending on what you need

  // No need to determine title here anymore, can be done in individual pages or AppHeader if kept

  return (
    <div class="flex flex-col sm:flex-row min-h-screen bg-bg-dark">
      {/* Pass the current path from the hook to Nav components */}
      <SidebarNav currentPath={path} class="hidden sm:flex" />

      <main class="flex-grow flex flex-col pb-16 sm:pb-0">
        {/* Optional Mobile Header - might need path prop if it displays title */}
        {/* <AppHeader currentPath={path} class="sm:hidden" /> */}

        {/* Render the matched Route component passed as children */}
        <div class="flex-grow p-4 overflow-y-auto">
           {children}
        </div>
      </main>

      {/* Pass the current path from the hook to Nav components */}
      <BottomNav currentPath={path} class="sm:hidden" />
    </div>
  );
};


// src/main.tsx
import "./App.css";
import { render } from "preact";
import App from "./App";

render(<App />, document.getElementById("root")!);


// src/pages/History.jsx
import { h } from 'preact';
import { useState, useEffect, useMemo } from 'preact/hooks';
import { invoke } from '@tauri-apps/api/core';
import { SlidersHorizontal, Calendar as CalendarIcon, ChevronRight, List, LayoutList, X, AlertTriangle, Loader2 } from 'lucide-preact'; // Added Loader2

// --- Helper to parse muscle strings "Chest,Triceps" or ["Chest", "Triceps"] into ['chest', 'triceps'] ---
const parseMuscles = (muscleData) => {
  if (!muscleData) return [];

  let musclesArray = [];
  if (typeof muscleData === 'string') {
    musclesArray = muscleData.split(',');
  } else if (Array.isArray(muscleData)) {
    musclesArray = muscleData.filter(m => typeof m === 'string');
  } else {
    console.warn('[parseMuscles] Unexpected data type for muscles:', muscleData);
    return [];
  }

  return musclesArray.map(m => m.trim().toLowerCase()).filter(Boolean);
};


// --- Updated WorkoutCard ---
const WorkoutCard = ({ workout, exerciseDef, onSelectWorkout }) => {
  // --- DURATION ---
  // workout.duration_minutes from Rust is i64, so it's whole minutes.
  let durationDisplay = null;
  if (workout.durationMinutes != null && workout.durationMinutes > 0) { // Corrected: workout.durationMinutes
    durationDisplay = `${workout.durationMinutes}m`;
  }

  // --- EXERCISE TYPE ---
  // workout.exercise_type from Rust -> workout.exerciseType in JS
  // exerciseDef.type_ is assumed to be correct based on your ExerciseDefinition structure.
  const exerciseType = workout.exerciseType || (exerciseDef ? exerciseDef.type_ : null); // Corrected: workout.exerciseType
  const isBodyweight = exerciseType && exerciseType.toLowerCase() === 'bodyweight';

  let metrics = [];
  if (workout.sets != null && workout.reps != null) {
    metrics.push(`${workout.sets} sets  ${workout.reps} reps`);
  }

  // --- WEIGHT LOGIC ---
  if (isBodyweight) {
    // For bodyweight exercises, workout.weight is considered added weight.
    // workout.bodyweight is the person's body weight at the time of the workout.
    const addedWeightValue = workout.weight != null ? Number(workout.weight) : null;
    const bodyWeightAtTime = workout.bodyweight != null ? Number(workout.bodyweight) : null; // Corrected: workout.bodyweight

    if (bodyWeightAtTime != null && !isNaN(bodyWeightAtTime)) {
      const currentAddedWeight = (addedWeightValue != null && !isNaN(addedWeightValue)) ? addedWeightValue : 0;
      const totalEffectiveWeight = currentAddedWeight + bodyWeightAtTime;

      if (currentAddedWeight > 0) {
        metrics.push(`${totalEffectiveWeight.toFixed(1)} kg (${bodyWeightAtTime.toFixed(1)} kg BW + ${currentAddedWeight.toFixed(1)} kg)`);
      } else { // Only bodyweight, or added weight is 0 or invalid
        metrics.push(`${bodyWeightAtTime.toFixed(1)} kg BW`);
      }
    } else if (addedWeightValue != null && !isNaN(addedWeightValue) && addedWeightValue > 0) {
      // Bodyweight exercise, but bodyWeightAtTime is missing or invalid.
      // Show only added weight if it's valid AND greater than 0.
      metrics.push(`${addedWeightValue.toFixed(1)} kg (added)`);
    }
    // If neither bodyWeightAtTime nor a positive addedWeightValue are present for a bodyweight exercise,
    // no specific weight metric is pushed. Sets/reps define the work.

  } else { // Not a bodyweight exercise, or type is unknown
    const standardWeightValue = workout.weight != null ? Number(workout.weight) : null;
    if (standardWeightValue != null && !isNaN(standardWeightValue)) {
      metrics.push(`${standardWeightValue.toFixed(1)} kg`); // Assuming kg
    }
  }
  // --- END OF WEIGHT LOGIC ---

  if (durationDisplay) {
    metrics.push(durationDisplay);
  }

  if (workout.distance != null) {
    const distanceValue = Number(workout.distance);
    if (!isNaN(distanceValue) && distanceValue > 0) { // Only show if valid and positive
        metrics.push(`${distanceValue.toFixed(1)} km`); // Assuming km
    }
  }

  return (
    <div
      class="bg-surface-alt p-4 rounded-lg border border-subtle hover:shadow-themed-md transition-shadow cursor-pointer relative flex flex-col justify-between group hover:bg-hover"
      onClick={() => onSelectWorkout(workout)}
    >
      <div>
        <h3 class="text-md font-semibold text-default truncate mb-1" title={workout.exercise_name}>
          {workout.exercise_name || "Unknown Exercise"}
        </h3>
        {exerciseType && <p class="text-xs text-muted mb-2">{exerciseType}</p>}
        {metrics.length > 0 && (
          <div class="mt-2 text-xs text-subtle space-y-0.5">
            {metrics.map((metric, index) => <p key={index}>{metric}</p>)}
          </div>
        )}
      </div>
      <ChevronRight class="absolute top-1/2 -translate-y-1/2 right-4 text-muted group-hover:text-primary" size={20} strokeWidth={2.5} />
    </div>
  );
};

// --- Simple Calendar Component (UPDATED) ---
const MiniCalendar = ({ year, month, onDateClick, activeDates, selectedDate, onMonthChange, isMainView = false }) => {
  const today = new Date();
  today.setHours(0, 0, 0, 0);

  const daysInMonth = (y, m) => new Date(y, m + 1, 0).getDate();
  const firstDayOfMonth = (y, m) => new Date(y, m, 1).getDay();

  const monthNames = ["Jan", "Feb", "Mar", "Apr", "May", "Jun", "Jul", "Aug", "Sep", "Oct", "Nov", "Dec"];

  const numDays = daysInMonth(year, month);
  const startOffset = firstDayOfMonth(year, month);

  const calendarDays = [];
  for (let i = 0; i < startOffset; i++) {
    calendarDays.push(<div key={`empty-${i}`} class="p-1 aspect-square"></div>);
  }
  for (let day = 1; day <= numDays; day++) {
    const dateStr = `${year}-${String(month + 1).padStart(2, '0')}-${String(day).padStart(2, '0')}`;
    const currentDateObj = new Date(year, month, day);
    currentDateObj.setHours(0, 0, 0, 0);

    const isToday = currentDateObj.getTime() === today.getTime();
    const isActive = activeDates.has(dateStr);
    const isSelected = selectedDate === dateStr;

    let dotColorClass = '';
    if (isActive) {
      // If the day is selected, use a dot color that contrasts with the primary background.
      // Assumes text-on-primary is a contrasting color (e.g., white on blue).
      if (isSelected) {
        dotColorClass = 'bg-[var(--color-text-on-accent)]';
      } else {
      // For active (but not selected) days, use the main theme accent color for the dot.
        dotColorClass = 'bg-[var(--color-accent-emphasis)]';
      }
    }

    calendarDays.push(
      <button
        key={day}
        onClick={() => onDateClick(dateStr)}
        disabled={!isActive && !isMainView && !isSelected}
        class={`p-1 w-full aspect-square flex flex-col items-center justify-center rounded-md text-xs transition-colors duration-150
          ${isSelected ? 'bg-primary text-on-primary font-semibold ring-2 ring-primary-focus' :
            isActive ? 'bg-accent-positive/10 text-accent-positive-emphasis hover:bg-accent-positive/20 font-medium' :
            isToday ? 'bg-hover text-subtle' : 'text-muted'}
          ${(!isActive && !isMainView && !isSelected) ? 'cursor-not-allowed opacity-50' : 'cursor-pointer hover:bg-hover'}
        `}
      >
        <span>{day}</span>
        {isActive && (
          <div class={`mt-0.5 w-1.5 h-1.5 rounded-full ${dotColorClass}`}></div>
        )}
      </button>
    );
  }

  const handlePrevMonth = () => {
    let newMonth = month - 1;
    let newYear = year;
    if (newMonth < 0) { newMonth = 11; newYear--; }
    onMonthChange(newYear, newMonth);
  };

  const handleNextMonth = () => {
    let newMonth = month + 1;
    let newYear = year;
    if (newMonth > 11) { newMonth = 0; newYear++; }
    onMonthChange(newYear, newMonth);
  };

  return (
    <div class="bg-app p-3 rounded-lg border border-divider shadow-themed-md">
      <div class="flex justify-between items-center mb-3">
        <button onClick={handlePrevMonth} class="p-1.5 hover:bg-hover rounded-full text-subtle">
          <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><polyline points="15 18 9 12 15 6"></polyline></svg>
        </button>
        <h3 class="font-semibold text-sm text-default">{monthNames[month]} {year}</h3>
        <button onClick={handleNextMonth} class="p-1.5 hover:bg-hover rounded-full text-subtle">
          <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><polyline points="9 18 15 12 9 6"></polyline></svg>
        </button>
      </div>
      <div class="grid grid-cols-7 gap-1 text-xs text-center text-muted mb-1 font-medium">
        <div>Su</div><div>Mo</div><div>Tu</div><div>We</div><div>Th</div><div>Fr</div><div>Sa</div>
      </div>
      <div class="grid grid-cols-7 gap-1">
        {calendarDays}
      </div>
    </div>
  );
};

// --- Main History Component ---
const History = () => {
  const [allWorkouts, setAllWorkouts] = useState([]);
  const [displayedWorkouts, setDisplayedWorkouts] = useState([]);
  const [exerciseDefinitions, setExerciseDefinitions] = useState([]);
  const [allMuscles, setAllMuscles] = useState([]);

  const [selectedExerciseNames, setSelectedExerciseNames] = useState(new Set());
  const [selectedMuscleGroups, setSelectedMuscleGroups] = useState(new Set());

  const [currentView, setCurrentView] = useState('list');

  const [calendarDate, setCalendarDate] = useState(new Date());
  const [selectedCalendarDate, setSelectedCalendarDate] = useState(null);

  const [isLoading, setIsLoading] = useState(true);
  const [error, setError] = useState(null);
  const [showMobileFilters, setShowMobileFilters] = useState(false);

  useEffect(() => {
    const fetchData = async () => {
      console.log("[HISTORY] Fetching initial data...");
      setIsLoading(true); setError(null);
      try {
        const [workoutsDataRaw, exercisesData, musclesData] = await Promise.all([
          invoke('list_workouts', { filters: {} }),
          invoke('list_exercises', { typeFilterStr: null, musclesFilter: null }),
          invoke('list_all_muscles')
        ]);

        if (!Array.isArray(workoutsDataRaw)) {
          console.error("[HISTORY] workoutsDataRaw is not an array:", workoutsDataRaw);
          setAllWorkouts([]);
        } else {
          const parsedWorkouts = workoutsDataRaw.map((w, index) => {
            const originalDateValue = w.timestamp;
            let parsedDate = null;
            let isValidDate = false;

            if (originalDateValue && typeof originalDateValue === 'string' && originalDateValue.trim() !== '') {
              parsedDate = new Date(originalDateValue);
              if (!isNaN(parsedDate.getTime())) {
                isValidDate = true;
              } else {
                if (/^\d{4}-\d{2}-\d{2}$/.test(originalDateValue)) {
                  parsedDate = new Date(originalDateValue + "T00:00:00Z");
                  if (!isNaN(parsedDate.getTime())) {
                    isValidDate = true;
                  } else if (index < 5) {
                     console.warn(`[HISTORY] Workout ${index} (id: ${w.id}): Invalid YYYY-MM-DD date: "${originalDateValue}"`);
                  }
                } else if (index < 5) {
                  console.warn(`[HISTORY] Workout ${index} (id: ${w.id}): Invalid date string (not RFC3339 or YYYY-MM-DD): "${originalDateValue}"`);
                }
              }
            } else if (originalDateValue && index < 5) {
              console.warn(`[HISTORY] Workout ${index} (id: ${w.id}): Non-string or empty date value: `, originalDateValue);
            }
            return { ...w, date: isValidDate ? parsedDate : null };
          });

          const validDateWorkouts = parsedWorkouts.filter(w => w.date !== null);
          setAllWorkouts(validDateWorkouts);
        }

        setExerciseDefinitions(Array.isArray(exercisesData) ? exercisesData : []);
        setAllMuscles(Array.isArray(musclesData) ? musclesData.sort() : []);

      } catch (err) {
        console.error("[HISTORY] CRITICAL ERROR fetching data:", err);
        setError(typeof err === 'string' ? err : (err.message || "Failed to load initial data."));
        setAllWorkouts([]);
        setExerciseDefinitions([]);
        setAllMuscles([]);
      } finally {
        setIsLoading(false);
      }
    };
    fetchData();
  }, []);

  const filteredActiveWorkoutDatesInMonth = useMemo(() => {
    const year = calendarDate.getFullYear();
    const month = calendarDate.getMonth();
    let workoutsToConsider = [...allWorkouts];

    if (selectedMuscleGroups.size > 0) {
      workoutsToConsider = workoutsToConsider.filter(workout => {
        let exerciseDef = exerciseDefinitions.find(def => def.id === workout.exercise_id);
        if (!exerciseDef && workout.exercise_name) {
            exerciseDef = exerciseDefinitions.find(def => def.name && workout.exercise_name && def.name.toLowerCase() === workout.exercise_name.toLowerCase());
        }
        if (!exerciseDef) return false;
        const workoutMusclesFromDef = parseMuscles(exerciseDef.muscles);
        const workoutMusclesOnDef = new Set(workoutMusclesFromDef);
        for (const selectedLowerMuscle of selectedMuscleGroups) {
          if (workoutMusclesOnDef.has(selectedLowerMuscle)) return true;
        }
        return false;
      });
    }
    if (selectedExerciseNames.size > 0) {
      workoutsToConsider = workoutsToConsider.filter(workout => selectedExerciseNames.has(workout.exercise_name));
    }
    const dates = new Set();
    workoutsToConsider.forEach(workout => {
      if (workout.date instanceof Date && !isNaN(workout.date.getTime())) {
        const d = workout.date;
        if (d.getFullYear() === year && d.getMonth() === month) {
          dates.add(d.toISOString().split('T')[0]);
        }
      }
    });
    return dates;
  }, [allWorkouts, selectedMuscleGroups, selectedExerciseNames, calendarDate, exerciseDefinitions]);

  const uniqueExerciseNames = useMemo(() => {
    const names = new Set(exerciseDefinitions.map(ex => ex.name).filter(Boolean));
    return Array.from(names).sort();
  }, [exerciseDefinitions]);

  useEffect(() => {
    let filtered = [...allWorkouts];
    if (selectedCalendarDate) {
      filtered = filtered.filter(workout => {
        if (!workout.date) return false;
        const workoutDateStr = workout.date.toISOString().split('T')[0];
        return workoutDateStr === selectedCalendarDate;
      });
    }
    if (selectedMuscleGroups.size > 0) {
      filtered = filtered.filter((workout) => {
        let exerciseDef = exerciseDefinitions.find(def => def.id === workout.exercise_id);
        if (!exerciseDef && workout.exercise_name) {
            exerciseDef = exerciseDefinitions.find(def => def.name && workout.exercise_name && def.name.toLowerCase() === workout.exercise_name.toLowerCase());
        }
        if (!exerciseDef) return false;
        const workoutMusclesFromDef = parseMuscles(exerciseDef.muscles);
        const workoutMusclesOnDef = new Set(workoutMusclesFromDef);
        for (const selectedLowerMuscle of selectedMuscleGroups) {
          if (workoutMusclesOnDef.has(selectedLowerMuscle)) return true;
        }
        return false;
      });
    }
    if (selectedExerciseNames.size > 0) {
      filtered = filtered.filter(workout => selectedExerciseNames.has(workout.exercise_name));
    }
    filtered.sort((a, b) => {
        if (!a.date && !b.date) return 0;
        if (!a.date) return 1;
        if (!b.date) return -1;
        return b.date.getTime() - a.date.getTime();
    });
    setDisplayedWorkouts(filtered);
  }, [allWorkouts, selectedExerciseNames, selectedMuscleGroups, exerciseDefinitions, selectedCalendarDate]);

  const groupedWorkoutsByDate = useMemo(() => {
    if (!displayedWorkouts || displayedWorkouts.length === 0) return [];
    const result = [];
    let currentGroup = null;
    for (const workout of displayedWorkouts) {
      if (workout.date) {
        const dateStr = workout.date.toISOString().split('T')[0];
        if (!currentGroup || currentGroup.dateIso !== dateStr) {
          currentGroup = { dateIso: dateStr, workoutsOnDate: [] };
          result.push(currentGroup);
        }
        currentGroup.workoutsOnDate.push(workout);
      }
    }
    return result;
  }, [displayedWorkouts]);

  const handleMuscleToggle = (muscleNameFromList) => {
    const lowerMuscleName = muscleNameFromList.toLowerCase();
    setSelectedMuscleGroups(prev => {
      const next = new Set(prev);
      if (next.has(lowerMuscleName)) next.delete(lowerMuscleName); else next.add(lowerMuscleName);
      return next;
    });
    if (currentView === 'list') setSelectedCalendarDate(null);
  };

  const handleExerciseToggle = (exerciseName) => {
    setSelectedExerciseNames(prev => {
      const next = new Set(prev);
      if (next.has(exerciseName)) next.delete(exerciseName); else next.add(exerciseName);
      return next;
    });
    if (currentView === 'list') setSelectedCalendarDate(null);
  };

  const handleCalendarDateClick = (dateStr) => {
    setSelectedCalendarDate(prev => (prev === dateStr ? null : dateStr));
  };

  const handleMonthChangeForCalendar = (year, month) => {
    setCalendarDate(new Date(year, month, 1));
  };

  const clearFilters = () => {
    setSelectedExerciseNames(new Set());
    setSelectedMuscleGroups(new Set());
    setSelectedCalendarDate(null);
  };

  const handleSelectWorkout = (workout) => {
    console.log("Selected workout (placeholder):", workout);
  };

  const FilterControls = ({ inModal = false }) => (
    <div class={`flex flex-col gap-4 ${inModal ? '' : 'bg-app p-4 rounded-xl border border-divider shadow-themed-md'}`}>
      {!inModal && <h2 class="text-lg font-semibold mb-3 text-default">Filters</h2>}
      <div>
        <h3 class="font-semibold mb-2 text-sm text-default">By Muscle</h3>
        <div class="max-h-40 overflow-y-auto space-y-1 text-xs pr-1">
          {allMuscles.map(muscle => (
            <label key={muscle} class="flex items-center space-x-2 p-1.5 hover:bg-hover rounded-md cursor-pointer">
              <input type="checkbox" class="form-checkbox h-3.5 w-3.5 text-primary focus:ring-primary/50 border-subtle rounded-sm"
                checked={selectedMuscleGroups.has(muscle.toLowerCase())} onChange={() => handleMuscleToggle(muscle)} />
              <span class="text-default">{muscle}</span>
            </label>
          ))}
        </div>
      </div>
      <div>
        <h3 class="font-semibold mb-2 text-sm text-default">By Exercise</h3>
        <div class="max-h-40 overflow-y-auto space-y-1 text-xs pr-1">
          {uniqueExerciseNames.map(exName => (
            <label key={exName} class="flex items-center space-x-2 p-1.5 hover:bg-hover rounded-md cursor-pointer">
              <input type="checkbox" class="form-checkbox h-3.5 w-3.5 text-primary focus:ring-primary/50 border-subtle rounded-sm"
                checked={selectedExerciseNames.has(exName)} onChange={() => handleExerciseToggle(exName)} />
              <span class="text-default">{exName}</span>
            </label>
          ))}
        </div>
      </div>
      {(selectedMuscleGroups.size > 0 || selectedExerciseNames.size > 0 || selectedCalendarDate) && (
        <button onClick={clearFilters} class="mt-2 w-full text-xs bg-hover hover:bg-app-alt text-default py-1.5 px-2 rounded-md flex items-center justify-center gap-1.5">
            <X size={14}/> Clear Filters
        </button>
      )}
    </div>
  );

  if (isLoading) return (
    <div class="p-6 text-center text-subtle flex flex-col items-center justify-center min-h-screen bg-surface">
        <Loader2 size={48} class="animate-spin text-primary mb-4" />
        <p class="text-lg">Loading workout history...</p>
    </div>
  );

  if (error) return (
    <div class="p-6 text-center text-accent-destructive bg-accent-destructive/10 rounded-lg border border-accent-destructive/20 m-4">
        <AlertTriangle class="mx-auto mb-2 text-accent-destructive" size={32} />
        <p class="font-semibold">Error loading data:</p>
        <p class="text-sm">{error}</p>
        <p class="text-xs mt-2 text-muted">Please check the browser console for more technical details.</p>
    </div>
  );

  return (
    <div class="flex flex-col sm:flex-row h-full gap-x-6 p-3 sm:p-4 bg-surface min-h-screen">
       <div class="hidden sm:block sm:w-1/3 lg:w-1/4 xl:w-1/5 flex-shrink-0 space-y-4 self-start sticky top-4">
        <FilterControls />
        <div class="bg-app p-1 rounded-xl border border-divider shadow-themed-md"> {/* Adjusted padding and rounded for consistency */}
          <MiniCalendar year={calendarDate.getFullYear()} month={calendarDate.getMonth()}
            activeDates={filteredActiveWorkoutDatesInMonth}
            selectedDate={selectedCalendarDate}
            onMonthChange={handleMonthChangeForCalendar}
            isMainView={false}
            onDateClick={(dateStr) => {
                handleCalendarDateClick(dateStr);
                setCurrentView('list');
            }}/>
        </div>
       </div>

       {showMobileFilters && (
         <div class="sm:hidden fixed inset-0 bg-black/60 z-40 backdrop-blur-sm" onClick={() => setShowMobileFilters(false)}>
            <div class="fixed top-0 right-0 h-full w-4/5 max-w-xs bg-surface p-5 shadow-themed-xl z-50 overflow-y-auto flex flex-col"
                onClick={(e) => e.stopPropagation()}>
                <div class="flex justify-between items-center mb-4">
                    <h2 class="text-lg font-semibold text-default">Filters & Calendar</h2>
                    <button onClick={() => setShowMobileFilters(false)} class="p-1 text-subtle hover:text-default"><X size={22} /></button>
                </div>
                <FilterControls inModal={true} />
                <div class="mt-5 border-t border-divider pt-4">
                  <h3 class="font-semibold mb-2 text-sm text-default">Calendar</h3>
                  <MiniCalendar year={calendarDate.getFullYear()} month={calendarDate.getMonth()}
                    activeDates={filteredActiveWorkoutDatesInMonth}
                    selectedDate={selectedCalendarDate}
                    onMonthChange={handleMonthChangeForCalendar}
                    isMainView={false} /* Should be false for sidebar/modal calendar */
                    onDateClick={(dateStr) => {
                        handleCalendarDateClick(dateStr);
setCurrentView('list');
                        setShowMobileFilters(false);
                    }}/>
                </div>
            </div>
         </div>
       )}

       <div class="flex-grow">
          <div class="flex justify-between items-center mb-4">
            <h1 class="text-xl md:text-2xl font-bold text-default">
                {currentView === 'list' && selectedCalendarDate
                    ? `Workouts on ${new Date(selectedCalendarDate + 'T00:00:00Z').toLocaleDateString(undefined, { year: 'numeric', month: 'long', day: 'numeric' })}`
                    : currentView === 'calendar'
                    ? 'Calendar View'
                    : "Workout History"}
            </h1>
            <div class="flex gap-1.5 items-center">
               <button onClick={() => setCurrentView('list')} title="List View"
                class={`p-2 rounded-full transition-colors ${currentView === 'list' ? 'bg-primary/10 text-primary' : 'text-subtle hover:bg-hover'}`}>
                   <LayoutList size={20} strokeWidth={2.5} />
               </button>
               <button onClick={() => setCurrentView('calendar')} title="Calendar View"
                class={`p-2 rounded-full transition-colors ${currentView === 'calendar' ? 'bg-primary/10 text-primary' : 'text-subtle hover:bg-hover'}`}>
                   <CalendarIcon size={20} strokeWidth={2.5} />
               </button>
               <button class="sm:hidden p-2 rounded-full text-subtle hover:bg-hover"
                  aria-label="Filters" onClick={() => setShowMobileFilters(true)}>
                   <SlidersHorizontal size={20} strokeWidth={2.5} />
               </button>
            </div>
          </div>

          {currentView === 'list' && (
            <>
              {selectedCalendarDate && (
                <button onClick={() => setSelectedCalendarDate(null)} class="mb-3 text-sm text-primary hover:underline font-medium">
                   Show all dates
                </button>
              )}
              {displayedWorkouts.length > 0 ? (
                <div class="space-y-6">
                  {groupedWorkoutsByDate.map(({ dateIso, workoutsOnDate }) => (
                    <div key={dateIso} class="bg-app p-4 sm:p-5 rounded-xl border border-divider shadow-themed-md">
                      <h2 class="text-base sm:text-lg font-semibold text-default mb-3 sm:mb-4 border-b border-divider pb-2 sm:pb-3">
                        {new Date(dateIso + 'T00:00:00Z').toLocaleDateString(undefined, { year: 'numeric', month: 'long', day: 'numeric' })}
                      </h2>
                      <div class="space-y-4">
                        {workoutsOnDate.map(workout => {
                          let exerciseDef = exerciseDefinitions.find(def => def.id === workout.exercise_id);
                          if (!exerciseDef && workout.exercise_name) {
                              exerciseDef = exerciseDefinitions.find(def => def.name && workout.exercise_name && def.name.toLowerCase() === workout.exercise_name.toLowerCase());
                          }
                          return <WorkoutCard key={workout.id} workout={workout} exerciseDef={exerciseDef} onSelectWorkout={handleSelectWorkout} />
                        })}
                      </div>
                    </div>
                  ))}
                </div>
              ) : (
                <div class="text-center py-12 text-subtle bg-app rounded-xl border border-divider shadow-themed-md">
                  <LayoutList size={40} class="mx-auto mb-3 text-muted" />
                  <p class="font-medium">
                    {isLoading ? "Loading..." : allWorkouts.length === 0 ? "No workouts found in your history." : "No workouts match your current filters."}
                  </p>
                  {(selectedMuscleGroups.size > 0 || selectedExerciseNames.size > 0 || selectedCalendarDate) && !isLoading && allWorkouts.length > 0 && (
                    <button onClick={clearFilters} class="mt-4 text-sm bg-primary text-on-primary hover:bg-primary/90 py-1.5 px-3.5 rounded-md font-medium">
                        Clear All Filters
                    </button>
                  )}
                </div>
              )}
            </>
          )}

          {currentView === 'calendar' && (
            <div class="bg-app p-3 sm:p-4 rounded-xl border border-divider shadow-themed-md">
              <MiniCalendar year={calendarDate.getFullYear()} month={calendarDate.getMonth()}
                activeDates={filteredActiveWorkoutDatesInMonth}
                selectedDate={selectedCalendarDate}
                onMonthChange={handleMonthChangeForCalendar}
                isMainView={true}
                onDateClick={(dateStr) => {
                    handleCalendarDateClick(dateStr);
                    setCurrentView('list');
                }}/>
              <p class="mt-3 text-xs text-center text-muted">
                Select a date to view workouts. Dates with workouts (matching current filters) are highlighted.
              </p>
            </div>
          )}
       </div>
    </div>
  );
};

export default History;


// src/pages/LogWorkout.jsx
import { h } from 'preact';
import { useState, useEffect, useCallback } from 'preact/hooks';
import { invoke } from '@tauri-apps/api/core';
// Added Edit3 icon
import { Calendar, Plus, ChevronLeft, ChevronRight, AlertTriangle, Loader2, Award, X as CloseIcon, Trash2, PlusSquare, Edit3 } from 'lucide-preact';
import DatePicker from '../components/DatePicker';
import AddExerciseModal from '../components/AddExerciseModal';

const processBackendWorkouts = (backendWorkouts) => {
  if (!backendWorkouts || backendWorkouts.length === 0) return [];
  const exerciseGroups = {};
  backendWorkouts.forEach(workout => {
    const exerciseName = workout.exercise_name;
    if (!exerciseName) {
      console.warn("Workout missing exercise_name:", workout);
      return;
    }
    if (!exerciseGroups[exerciseName]) {
      exerciseGroups[exerciseName] = {
        name: exerciseName,
        logEntries: [],
      };
    }
    const metrics = {};
    if (workout.reps != null) metrics.reps = workout.reps;
    if (workout.weight != null) metrics.weight = workout.weight;
    if (workout.duration_minutes != null) metrics.duration = workout.duration_minutes;
    if (workout.distance != null) metrics.distance = workout.distance;

    // Handle multiple sets from a single backend workout entry
    // workout.sets comes from the backend (e.g., Option<i64> in Rust, so can be null)
    const numberOfSets = (workout.sets != null && workout.sets > 0) ? Number(workout.sets) : 1;

    for (let i = 0; i < numberOfSets; i++) {
      exerciseGroups[exerciseName].logEntries.push({
        // uiId: Unique ID for UI rendering (React key).
        // All "exploded" sets from the same DB row will have different uiId.
        uiId: `${workout.id}-${i}`,
        // dbId: The original database ID.
        // All "exploded" sets from the same DB row will share this dbId for backend operations.
        dbId: workout.id,
        metrics: { ...metrics }, // Clone metrics (they are the same for each expanded set from this row)
        exerciseName: exerciseName, // Keep exercise name for edit pre-selection
        // Optional: for potential display like "Set 1 of 3"
        // setDisplayNumber: i + 1,
        // totalSetsInParentRecord: numberOfSets,
      });
    }
  });
  return Object.values(exerciseGroups).filter(group => group.logEntries && group.logEntries.length > 0);
};


const LogWorkout = () => {
  const [currentDate, setCurrentDate] = useState(new Date());
  const [formattedDate, setFormattedDate] = useState("");
  const [dateKey, setDateKey] = useState("");
  const [workoutData, setWorkoutData] = useState([]);
  const [loading, setLoading] = useState(true);
  const [error, setError] = useState(null);

  const [showDatePicker, setShowDatePicker] = useState(false);
  const [showAddExerciseModal, setShowAddExerciseModal] = useState(false);

  const [pbNotification, setPbNotification] = useState(null);
  const [userConfigUnits, setUserConfigUnits] = useState('metric');

  const [allExerciseDefinitionsMap, setAllExerciseDefinitionsMap] = useState(new Map());
  const [preSelectedExerciseForModal, setPreSelectedExerciseForModal] = useState(null);
  const [initialLogDataForModal, setInitialLogDataForModal] = useState(null);
  const [editingWorkoutLogId, setEditingWorkoutLogId] = useState(null); // Stores the dbId for edit mode

  const dateFormatOptions = { weekday: 'long', year: 'numeric', month: 'long', day: 'numeric' };

  useEffect(() => { /* fetchAllDefs - remains same */
    const fetchAllDefs = async () => {
      try {
        const defs = await invoke('list_exercises', { typeFilterStr: null, muscleFilter: null });
        const map = new Map();
        (defs || []).forEach(def => map.set(def.name, def));
        setAllExerciseDefinitionsMap(map);
      } catch (err) { console.error("LogWorkout: Failed to fetch all exercise definitions:", err); }
    };
    fetchAllDefs();
  }, []);
  useEffect(() => { /* fetchUserConfig - remains same */
    const fetchUserConfig = async () => {
      try {
        const config = await invoke('get_config');
        if (config && config.units) setUserConfigUnits(config.units.toLowerCase());
      } catch (err) { console.error("LogWorkout: Failed to fetch user config:", err); }
    };
    fetchUserConfig();
  }, []);
  const changeDate = (days) => { /* ... */
    const newDate = new Date(currentDate);
    newDate.setDate(newDate.getDate() + days);
    setCurrentDate(newDate);
    setShowDatePicker(false);
  };
  const fetchWorkoutsForCurrentDate = useCallback(async () => { /* ... */
    if (!dateKey) return;
    setLoading(true); setError(null); setWorkoutData([]);
    try {
      const filters = { date: dateKey };
      const backendRawWorkouts = await invoke('list_workouts', { filters });
      setWorkoutData(processBackendWorkouts(backendRawWorkouts));
    } catch (err) {
      const errorMessage = typeof err === 'string' ? err : (err.message || "Error fetching workouts.");
      console.error("Fetch workouts error:", err); setError(errorMessage);
    } finally { setLoading(false); }
  }, [dateKey]);
  useEffect(() => { /* dateKey update - remains same */
    setFormattedDate(currentDate.toLocaleDateString(undefined, dateFormatOptions));
    const year = currentDate.getFullYear();
    const month = String(currentDate.getMonth() + 1).padStart(2, '0');
    const day = String(currentDate.getDate()).padStart(2, '0');
    setDateKey(`${year}-${month}-${day}`);
  }, [currentDate]);
  useEffect(() => { /* fetchWorkoutsForCurrentDate call - remains same */
    fetchWorkoutsForCurrentDate();
  }, [fetchWorkoutsForCurrentDate]);

  const handleModalActionCompleted = (pbInfo) => {
    fetchWorkoutsForCurrentDate();
    setEditingWorkoutLogId(null);

    if (pbInfo) {
      const anyPbAchieved = pbInfo.weight?.achieved || pbInfo.reps?.achieved || pbInfo.duration?.achieved || pbInfo.distance?.achieved;
      if (anyPbAchieved) setPbNotification(pbInfo);
      else setPbNotification(null);
    } else {
      setPbNotification(null);
    }
  };

  const fetchWorkoutDatesForCalendarMonth = useCallback(async (year, month_one_indexed) => { /* ... */
    try {
      const datesArray = await invoke('get_workout_dates_for_month', { query: { year: year, month: month_one_indexed } });
      return datesArray || [];
    } catch (err) { console.error("LogWorkout: Failed to fetch workout dates:", err); return []; }
  }, []);
  const handleDateSelectFromPicker = (newDate) => { /* ... */ setCurrentDate(newDate); setShowDatePicker(false); };
  const formatPbValue = (value, type) => { /* ... (remains same) */
    if (value == null) return 'N/A';
    switch (type) {
      case 'weight': return `${value.toFixed(1)} ${userConfigUnits === 'imperial' ? 'lbs' : 'kg'}`;
      case 'reps': return `${value} reps`;
      case 'duration': return `${value} min`;
      case 'distance': return userConfigUnits === 'imperial' ? `${(value * 0.621371).toFixed(2)} miles` : `${value.toFixed(2)} km`;
      default: return value.toString();
    }
  };

  const handleOpenAddExerciseModal = () => {
    setPreSelectedExerciseForModal(null);
    setInitialLogDataForModal(null);
    setEditingWorkoutLogId(null);
    setShowAddExerciseModal(true);
  };

  const handleCloseAddExerciseModal = () => {
    setShowAddExerciseModal(false);
    setPreSelectedExerciseForModal(null);
    setInitialLogDataForModal(null);
    setEditingWorkoutLogId(null);
  };

  const handleOpenAddSetModal = useCallback((exerciseName, metricsToCopy) => {
    const definition = allExerciseDefinitionsMap.get(exerciseName);
    if (definition) {
      setPreSelectedExerciseForModal(definition);
      const modalLogData = {
        reps: metricsToCopy.reps?.toString() || '',
        weight: metricsToCopy.weight?.toString() || '',
        duration: metricsToCopy.duration?.toString() || '',
        distance: metricsToCopy.distance?.toString() || ''
      };
      setInitialLogDataForModal(modalLogData);
      setEditingWorkoutLogId(null);
      setShowAddExerciseModal(true);
    } else {
      console.warn(`Def for "${exerciseName}" not found.`);
      handleOpenAddExerciseModal();
    }
  }, [allExerciseDefinitionsMap]);

  const handleOpenEditSetModal = useCallback((logEntryToEdit) => {
    // logEntryToEdit is an object like: { uiId: "...", dbId: original_db_id, metrics: {...}, exerciseName: "..." }
    const exerciseName = logEntryToEdit.exerciseName;
    const definition = allExerciseDefinitionsMap.get(exerciseName);

    if (definition) {
      setPreSelectedExerciseForModal(definition);
      const modalLogData = {
        reps: logEntryToEdit.metrics.reps?.toString() || '',
        weight: logEntryToEdit.metrics.weight?.toString() || '',
        duration: logEntryToEdit.metrics.duration?.toString() || '',
        distance: logEntryToEdit.metrics.distance?.toString() || ''
      };
      setInitialLogDataForModal(modalLogData);
      setEditingWorkoutLogId(logEntryToEdit.dbId); // Use dbId for editing the backend record
      setShowAddExerciseModal(true);
    } else {
      console.error(`Cannot edit: Exercise definition for "${exerciseName}" not found.`);
    }
  }, [allExerciseDefinitionsMap]);


  const handleDeleteWorkoutLogEntry = async (logEntryDbId) => { // Parameter is dbId
    if (!logEntryDbId) return;
    try {
      setLoading(true);
      // Deleting any "exploded" set deletes the original backend record.
      await invoke('delete_workouts', { ids: [logEntryDbId] });
      fetchWorkoutsForCurrentDate(); // Refresh the list
    } catch (err) { console.error("Failed to delete log entry:", err); setError(typeof err === 'string' ? err : (err.message || "Failed to delete entry.")); }
    finally {
      // setLoading(false); // fetchWorkoutsForCurrentDate will handle its own loading state
    }
  };

  return (
    <div className="flex flex-col h-full bg-surface rounded-lg shadow-themed-lg p-4 sm:p-6 relative">
      {/* Date Navigation Bar (remains same) */}
      <div className="flex items-center justify-between mb-6 sm:mb-8 bg-app p-3 sm:p-4 rounded-xl shadow-themed-md border border-divider relative">
        <button onClick={() => changeDate(-1)} className="p-2 sm:p-3 rounded-full hover:bg-hover transition-colors text-default" aria-label="Previous day"><ChevronLeft size={24} strokeWidth={2} /></button>
        <div className="flex items-center gap-2 sm:gap-3 cursor-pointer hover:bg-hover p-2 rounded-md date-display-toggle" onClick={() => setShowDatePicker(prev => !prev)}><Calendar size={20} className="text-accent-emphasis" /><span className="text-md sm:text-xl font-semibold text-default">{formattedDate}</span></div>
        <button onClick={() => changeDate(1)} className="p-2 sm:p-3 rounded-full hover:bg-hover transition-colors text-default" aria-label="Next day"><ChevronRight size={24} strokeWidth={2} /></button>
        {showDatePicker && (<div className="date-picker-container"><DatePicker initialSelectedDate={currentDate} onDateSelect={handleDateSelectFromPicker} onClose={() => setShowDatePicker(false)} fetchHighlightedDatesForMonth={fetchWorkoutDatesForCalendarMonth}/></div>)}
      </div>

      <div className="flex-grow mt-4 sm:mt-6">
        <div className="space-y-6 sm:space-y-8 relative">
          <div className="flex items-center justify-between mb-4">
            <button onClick={handleOpenAddExerciseModal} className="p-3 rounded-full bg-accent-emphasis text-on-accent shadow-themed-lg hover:bg-accent-emphasis-hover transition-colors flex items-center justify-center" aria-label="Add exercise"><Plus size={20} strokeWidth={2.5} /></button>
          </div>

          {loading && !workoutData.length ? ( /* Loader UI */ <div className="flex flex-col items-center justify-center text-subtle bg-app p-8 rounded-xl shadow-themed-md border border-divider min-h-[200px]"><Loader2 size={48} className="animate-spin text-accent-emphasis mb-4" /><p className="text-lg">Loading workouts...</p></div>
          ) : error ? ( /* Error UI */ <div className="bg-accent-destructive/10 border border-accent-destructive/20 p-6 rounded-xl shadow-themed-md text-accent-destructive"><div className="flex items-center mb-2"> <AlertTriangle size={24} className="mr-3 text-accent-destructive" /> <h3 className="text-xl font-semibold">Error</h3> </div><p>{error}</p></div>
          ) : workoutData.length > 0 ? (
            <div className="space-y-6 sm:space-y-8">
              {workoutData.map((exerciseGroup) => (
                <ExerciseCard
                  key={exerciseGroup.name}
                  exerciseGroup={exerciseGroup}
                  userConfigUnits={userConfigUnits}
                  onOpenAddSetModal={handleOpenAddSetModal}
                  onOpenEditSetModal={handleOpenEditSetModal}
                  onDeleteWorkoutLogEntry={handleDeleteWorkoutLogEntry}
                />
              ))}
            </div>
          ) : ( /* Empty state UI */ <div className="bg-app p-8 rounded-xl shadow-themed-md border border-divider text-center min-h-[200px] flex flex-col justify-center items-center"><Calendar size={48} className="text-muted mb-4" /><div className="text-subtle text-lg">No exercises logged for this day.</div><p className="text-muted mt-2 text-sm"> Tap the <Plus size={14} className="inline align-middle text-muted"/> button to add an exercise or pick another date. </p></div>
          )}
        </div>
      </div>

      <AddExerciseModal
        isOpen={showAddExerciseModal}
        onClose={handleCloseAddExerciseModal}
        currentDateKey={dateKey}
        onActionCompleted={handleModalActionCompleted}
        preSelectedExercise={preSelectedExerciseForModal}
        initialLogData={initialLogDataForModal}
        editingWorkoutLogId={editingWorkoutLogId} // This is dbId
      />

      {/* PB Notification Toast (remains same) */}
      {pbNotification && ( <div className="bg-primary fixed bottom-4 right-4 sm:bottom-6 sm:right-6 z-[200] bg-accent-positive text-on-accent-positive p-4 rounded-lg shadow-2xl w-full max-w-xs sm:max-w-sm border border-accent-positive-emphasis animate-slide-in-bottom" role="alert" aria-live="assertive"><div className="flex items-start"><Award size={24} className="mr-3 mt-1 text-current flex-shrink-0" /><div className="flex-grow"><h3 className="text-lg font-semibold mb-2">New Personal Best!</h3><ul className="space-y-1 text-sm"> {pbNotification.weight?.achieved && (<li><strong>Weight:</strong> {formatPbValue(pbNotification.weight.new_value, 'weight')}{pbNotification.weight.previous_value != null && (<span className="text-xs opacity-80 ml-1">(prev: {formatPbValue(pbNotification.weight.previous_value, 'weight')})</span>)}</li>)} {pbNotification.reps?.achieved && (<li><strong>Reps:</strong> {formatPbValue(pbNotification.reps.new_value, 'reps')}{pbNotification.reps.previous_value != null && (<span className="text-xs opacity-80 ml-1">(prev: {formatPbValue(pbNotification.reps.previous_value, 'reps')})</span>)}</li>)} {pbNotification.duration?.achieved && (<li><strong>Duration:</strong> {formatPbValue(pbNotification.duration.new_value, 'duration')}{pbNotification.duration.previous_value != null && (<span className="text-xs opacity-80 ml-1">(prev: {formatPbValue(pbNotification.duration.previous_value, 'duration')})</span>)}</li>)} {pbNotification.distance?.achieved && (<li><strong>Distance:</strong> {formatPbValue(pbNotification.distance.new_value, 'distance')}{pbNotification.distance.previous_value != null && (<span className="text-xs opacity-80 ml-1">(prev: {formatPbValue(pbNotification.distance.previous_value, 'distance')})</span>)}</li>)} </ul></div><button onClick={() => setPbNotification(null)} className="ml-2 p-1.5 rounded-full hover:bg-white/20 transition-colors flex-shrink-0" aria-label="Dismiss PB notification"><CloseIcon size={18} /></button></div></div> )}
    </div>
  );
};

const SetItem = ({ logEntry, index, userConfigUnits, onEdit, onDelete }) => (
  // logEntry is now an object like { uiId, dbId, metrics, exerciseName }
  <div className="bg-surface-alt p-3 rounded-lg border border-subtle flex items-center justify-between gap-x-2">
    <div className="flex flex-wrap gap-2 sm:gap-3 items-stretch flex-grow">
      {Object.keys(logEntry.metrics).length === 0 ? (
        <p className="text-sm text-muted italic flex-grow">Set logged (no specific metrics).</p>
      ) : (
        <>
          {logEntry.metrics.reps != null && (<div className="flex-1 min-w-[60px] sm:min-w-[70px] p-1.5 text-center bg-app rounded-md shadow-themed-sm border border-subtle"><span className="block text-md sm:text-lg font-semibold text-default">{logEntry.metrics.reps}</span><span className='block text-xs text-accent-emphasis font-medium'>Reps</span></div>)}
          {logEntry.metrics.weight != null && (<div className="flex-1 min-w-[60px] sm:min-w-[70px] p-1.5 text-center bg-app rounded-md shadow-themed-sm border border-subtle"><span className="block text-md sm:text-lg font-semibold text-default">{logEntry.metrics.weight}</span><span className="block text-xs text-subtle">{userConfigUnits === 'imperial' ? 'lbs' : 'kg'}</span></div>)}
          {logEntry.metrics.duration != null && (<div className="flex-1 min-w-[60px] sm:min-w-[70px] p-1.5 text-center bg-app rounded-md shadow-themed-sm border border-subtle"><span className="block text-md sm:text-lg font-semibold text-default">{logEntry.metrics.duration}</span><span className="block text-xs text-subtle">min</span></div>)}
          {logEntry.metrics.distance != null && (<div className="flex-1 min-w-[60px] sm:min-w-[70px] p-1.5 text-center bg-app rounded-md shadow-themed-sm border border-subtle"><span className="block text-md sm:text-lg font-semibold text-default">{logEntry.metrics.distance}</span><span className="block text-xs text-subtle">{userConfigUnits === 'imperial' ? 'miles' : 'km'}</span></div>)}
        </>
      )}
    </div>
    <div class="flex items-center gap-1 flex-shrink-0">
        <button
          onClick={() => onEdit(logEntry)} // Pass the whole logEntry, onEdit handler will use logEntry.dbId
          title="Edit this set"
          className="p-1.5 text-accent-subtle hover:text-accent-emphasis hover:bg-hover rounded-full transition-colors"
        >
          <Edit3 size={18} />
        </button>
        <button
          onClick={() => onDelete(logEntry.dbId)} // Pass dbId for deletion
          title="Delete this set"
          className="p-1.5 text-accent-destructive hover:text-accent-destructive-hover hover:bg-hover rounded-full transition-colors"
        >
          <Trash2 size={18} />
        </button>
    </div>
  </div>
);

const ExerciseCard = ({ exerciseGroup, userConfigUnits, onOpenAddSetModal, onOpenEditSetModal, onDeleteWorkoutLogEntry }) => {
  const lastLogEntryMetrics = exerciseGroup.logEntries.length > 0
    ? exerciseGroup.logEntries[exerciseGroup.logEntries.length - 1].metrics
    : {};

  return (
    <div className='mb-2'>
      <div className="bg-app p-4 sm:p-5 rounded-xl shadow-themed-lg border border-subtle flex flex-col">
        <div className="flex items-center justify-between mb-4">
          <h3 className="text-lg sm:text-xl font-semibold text-default">{exerciseGroup.name}</h3>
          <button onClick={() => onOpenAddSetModal(exerciseGroup.name, lastLogEntryMetrics)} title="Add another set for this exercise" className="p-1.5 text-accent-emphasis hover:text-accent-emphasis-hover hover:bg-hover rounded-full transition-colors">
            <PlusSquare size={20} />
          </button>
        </div>
        {exerciseGroup.logEntries && exerciseGroup.logEntries.length > 0 ? (
          <div className="space-y-3">
            {exerciseGroup.logEntries.map((logEntry, idx) => ( // logEntry is { uiId, dbId, ... }
              <SetItem
                key={logEntry.uiId} // Use uiId for React key
                logEntry={logEntry}
                index={idx}
                userConfigUnits={userConfigUnits}
                onEdit={onOpenEditSetModal} // onOpenEditSetModal expects the full logEntry
                onDelete={onDeleteWorkoutLogEntry} // onDeleteWorkoutLogEntry expects the dbId
              />
            ))}
          </div>
        ) : ( <p className="text-sm text-muted">No sets recorded for this exercise today.</p> )}
      </div>
    </div>
  );
};

export default LogWorkout;


// src/pages/Profile.jsx
import { h } from 'preact';
import { useState, useEffect, useCallback } from 'preact/hooks';
import { invoke } from '@tauri-apps/api/core';
import List from 'preact-material-components/List';
import Switch from 'preact-material-components/Switch';
import Select from 'preact-material-components/Select';

import 'preact-material-components/List/style.css';
import 'preact-material-components/Switch/style.css';
import 'preact-material-components/Select/style.css';
// import 'preact-material-components/Menu/style.css'; // May be needed by Select

import { UserCircle2, Bell, Palette, Settings, Target, Weight, Repeat, Clock, Route, HelpCircle, Heart, ChevronRight, Sun, Moon } from 'lucide-preact';

export const GUI_THEME_STORAGE_KEY = 'appGuiTheme';

// Define your themes
export const AVAILABLE_THEMES = [
  { id: 'default-light', name: 'Default Light' },
  { id: 'default-dark', name: 'Default Dark' },
  { id: 'catppuccin-latte', name: 'Catppuccin Latte' },
  { id: 'catppuccin-mocha', name: 'Catppuccin Mocha' },
  // Add more themes here e.g. { id: 'nord', name: 'Nord Theme' },
];

const SettingsItem = ({ icon: Icon, primary, secondary, actionComponent, onClick, className }) => (
   <List.Item onClick={onClick} className={`!py-3 !px-4 flex items-center justify-between w-full ${className || ''}`}>
       <div class="flex items-center flex-grow">
           {Icon && <Icon class="w-5 h-5 text-secondary mr-4 flex-shrink-0" strokeWidth={2} />}
           <List.TextContainer class="flex-grow">
               <List.PrimaryText class="text-sm font-medium text-primary">{primary}</List.PrimaryText>
               {secondary && <List.SecondaryText class="text-xs text-secondary">{secondary}</List.SecondaryText>}
           </List.TextContainer>
       </div>
       <div class="flex-shrink-0 ml-2">
        {actionComponent ? actionComponent : (onClick ? <ChevronRight class="w-4 h-4 text-secondary" strokeWidth={2} /> : null)}
       </div>
   </List.Item>
);


const Profile = () => {
  const [config, setConfig] = useState(null);
  const [isLoading, setIsLoading] = useState(true);
  const [error, setError] = useState('');
  const [currentGuiTheme, setCurrentGuiTheme] = useState(() => {
    if (typeof window !== 'undefined') {
      return localStorage.getItem(GUI_THEME_STORAGE_KEY) || AVAILABLE_THEMES[0].id;
    }
    return AVAILABLE_THEMES[0].id;
  });

  // State for new bodyweight input
  const [newBodyweight, setNewBodyweight] = useState('');
  const [addBodyweightMessage, setAddBodyweightMessage] = useState({ text: '', type: '' }); // {text, type: 'success' | 'error' | 'warning'}

  // Apply GUI theme to HTML element
  useEffect(() => {
    if (typeof window !== 'undefined') {
      // Remove all theme-prefixed classes
      AVAILABLE_THEMES.forEach(theme => document.documentElement.classList.remove(`theme-${theme.id}`));
      // Add current theme class
      document.documentElement.classList.add(`theme-${currentGuiTheme}`);
      localStorage.setItem(GUI_THEME_STORAGE_KEY, currentGuiTheme);
    }
  }, [currentGuiTheme]);

  // Fetch backend config
  useEffect(() => {
    const loadConfig = async () => {
      try {
        setIsLoading(true);
        const fetchedConfig = await invoke('get_config');
        setConfig(fetchedConfig);
        setError('');
      } catch (err) {
        console.error("Failed to load config:", err);
        setError(`Failed to load config: ${err.toString()}`);
      } finally {
        setIsLoading(false);
      }
    };
    loadConfig();
  }, []);

  const handleSettingChange = useCallback(async (command, payload, updateFn) => {
    try {
      await invoke(command, payload);
      setConfig(prevConfig => updateFn(prevConfig, payload));
      setError('');
    } catch (err) {
      console.error(`Failed to update setting (${command}):`, err);
      setError(`Failed to update ${command}: ${err.toString()}`);
    }
  }, []);

  const handleThemeChange = (event) => {
    setCurrentGuiTheme(AVAILABLE_THEMES[event.target.selectedIndex].id);
  };

  // Handler for adding a new bodyweight entry
  const handleAddBodyweightEntry = async () => {
    const weightVal = parseFloat(newBodyweight);
    if (!newBodyweight || isNaN(weightVal) || weightVal <= 0) {
      setAddBodyweightMessage({ text: 'Please enter a valid positive bodyweight.', type: 'error' });
      setTimeout(() => setAddBodyweightMessage({ text: '', type: '' }), 3000);
      return;
    }

    setAddBodyweightMessage({ text: '', type: '' }); // Clear previous message

    try {
      await invoke('add_bodyweight_entry', { weight: weightVal });
      setAddBodyweightMessage({ 
        text: `Bodyweight ${weightVal} ${config.units === 'metric' ? 'kg' : 'lbs'} logged successfully.`, 
        type: 'success' 
      });
      setNewBodyweight(''); // Clear input

      // Re-fetch config to get updated current_bodyweight and reflect it
      try {
        const fetchedConfig = await invoke('get_config');
        setConfig(fetchedConfig);
      } catch (fetchErr) {
        console.error("Failed to re-fetch config after adding bodyweight:", fetchErr);
        setAddBodyweightMessage({ 
          text: `Bodyweight logged, but failed to refresh settings: ${fetchErr.toString()}`, 
          type: 'warning'
        });
      }

    } catch (err) {
      console.error("Failed to add bodyweight entry:", err);
      setAddBodyweightMessage({ text: `Error logging bodyweight: ${err.toString()}`, type: 'error' });
    }
    // Clear message after a few seconds, unless it's a warning from config refresh
    if (addBodyweightMessage.type !== 'warning') {
        setTimeout(() => setAddBodyweightMessage({ text: '', type: '' }), 5000);
    }
  };


  if (isLoading) {
    return <div class="p-4 text-primary">Loading settings...</div>;
  }
  if (error) {
    return <div class="p-4 text-error">Error: {error}</div>;
  }
  if (!config) {
    return <div class="p-4 text-primary">Configuration not available.</div>;
  }

  const selectedThemeIndex = AVAILABLE_THEMES.findIndex(theme => theme.id === currentGuiTheme);

  return (
    <div class="flex flex-col sm:flex-row h-full gap-6 p-4 sm:p-6 bg-primary">
       <div class="flex-grow space-y-6">
            {/* App Preferences Section */}
            <div>
                <h3 class="text-xs uppercase text-secondary font-semibold mb-2 px-4 sm:px-0">App Preferences</h3>
                <List class="bg-secondary rounded-md border border-border-primary p-0">
                    <SettingsItem
                        icon={Palette}
                        primary="GUI Theme"
                        actionComponent={
                           <Select
                                selectedIndex={selectedThemeIndex === -1 ? 0 : selectedThemeIndex}
                                onChange={handleThemeChange}
                                // Add custom chevron for select if needed, or style default
                                // Ensure Select is styled or preact-material-components styling is applied correctly
                                className="text-sm text-primary bg-input border-border-input rounded-md" // Example styling
                           >
                               {AVAILABLE_THEMES.map(theme => (
                                   <Select.Item key={theme.id} value={theme.id}>{theme.name}</Select.Item>
                               ))}
                           </Select>
                        }
                    />
                    <SettingsItem
                        icon={Settings}
                        primary="Measurement Units"
                        actionComponent={
                            <Select
                                selectedIndex={config.units === 'metric' ? 0 : 1}
                                onChange={(e) => {
                                    const newUnitsValue = e.target.selectedIndex === 0 ? 'metric' : 'imperial';
                                    const setUnitsPayloadContent = { units: newUnitsValue };
                                    handleSettingChange(
                                        'set_units', 
                                        { payload: setUnitsPayloadContent }, 
                                        (prevConfig, invokedArgs) => ({ ...prevConfig, units: invokedArgs.payload.units })
                                    );
                                }}
                                className="text-sm text-primary bg-input border-border-input rounded-md" // Example styling
                            >
                                <Select.Item>Metric (kg, km)</Select.Item>
                                <Select.Item>Imperial (lbs, miles)</Select.Item>
                            </Select>
                        }
                    />
                    <SettingsItem
                        icon={Weight}
                        primary="Prompt for Bodyweight"
                        secondary="Ask for bodyweight before relevant workouts"
                        actionComponent={
                            <Switch
                                class="scale-75"
                                checked={config.prompt_for_bodyweight}
                                onChange={() => handleSettingChange('set_bodyweight_prompt_enabled', { enabled: !config.prompt_for_bodyweight },
                                    (prev, payload) => ({...prev, prompt_for_bodyweight: payload.enabled })
                                )}
                            />
                        }
                    />
                     <SettingsItem
                        icon={Target}
                        primary="Target Bodyweight"
                        secondary={config.target_bodyweight ? `${config.target_bodyweight} ${config.units === 'metric' ? 'kg' : 'lbs'}` : "Not set"}
                        actionComponent={
                            <input
                                type="number"
                                placeholder="e.g., 70"
                                step="0.1"
                                value={config.target_bodyweight === null || config.target_bodyweight === undefined ? '' : config.target_bodyweight}
                                onBlur={(e) => {
                                    const val = e.target.value;
                                    const newWeight = val === '' ? null : parseFloat(val);
                                    if (val === '' || (!isNaN(newWeight) && newWeight > 0)) {
                                        handleSettingChange('set_target_bodyweight', { weight: newWeight },
                                            (prev, payload) => ({...prev, target_bodyweight: payload.weight })
                                        );
                                    } else if (val !== '') {
                                        alert("Invalid target bodyweight. Must be a positive number or empty.");
                                        e.target.value = config.target_bodyweight === null || config.target_bodyweight === undefined ? '' : config.target_bodyweight;
                                    }
                                }}
                                // Example styling for consistency
                                class="bg-input border border-border-input text-primary text-sm rounded-md p-2 w-24 text-right focus:ring-accent-primary focus:border-accent-primary"
                            />
                        }
                    />
                     <SettingsItem
                        icon={Repeat}
                        primary="Streak Interval (Days)"
                        secondary={`Workouts within ${config.streak_interval_days} day(s) count as a streak`}
                        actionComponent={
                             <input
                                type="number"
                                min="1"
                                value={config.streak_interval_days}
                                onChange={(e) => { // Optimistic UI update
                                    const newDays = parseInt(e.target.value, 10);
                                    if (!isNaN(newDays) && newDays >=1) {
                                      setConfig(prev => ({...prev, streak_interval_days: newDays}));
                                    }
                                }}
                                onBlur={(e) => {
                                    const newDays = parseInt(e.target.value, 10);
                                    if (!isNaN(newDays) && newDays >= 1) {
                                        handleSettingChange('set_streak_interval', { days: newDays },
                                            (prev, payload) => ({...prev, streak_interval_days: payload.days })
                                        );
                                    } else {
                                        alert("Streak interval must be at least 1 day.");
                                        // Revert to original config value if input is invalid
                                        setConfig(prev => ({...prev, streak_interval_days: prev.streak_interval_days }));
                                        e.target.value = config.streak_interval_days; // Also revert input field
                                    }
                                }}
                                class="bg-input border border-border-input text-primary text-sm rounded-md p-2 w-16 text-right focus:ring-accent-primary focus:border-accent-primary"
                            />
                        }
                    />
                </List>
            </div>

            {/* Bodyweight Log Section */}
            <div>
                <h3 class="text-xs uppercase text-secondary font-semibold mb-2 px-4 sm:px-0">Bodyweight Log</h3>
                <div class="bg-secondary rounded-md border border-border-primary p-4 space-y-3">
                    <div class="flex flex-col sm:flex-row sm:items-center justify-between gap-2">
                        <p class="text-xs text-secondary flex-grow">
                            Log your current bodyweight. This will be recorded with today's date.
                            {config.current_bodyweight && (
                                <span class="block mt-1">
                                    Latest recorded: {config.current_bodyweight} {config.units === 'metric' ? 'kg' : 'lbs'}
                                </span>
                            )}
                        </p>
                    </div>
                    <div class="flex items-center gap-2 w-full">
                        <Weight class="w-5 h-5 text-secondary mr-2 flex-shrink-0" strokeWidth={2} />
                        <input
                            type="number"
                            placeholder={`New Bodyweight (${config.units === 'metric' ? 'kg' : 'lbs'})`}
                            step="0.1"
                            min="0"
                            value={newBodyweight}
                            onChange={(e) => setNewBodyweight(e.target.value)}
                            class="bg-input border border-border-input text-primary text-sm rounded-md p-2 flex-grow focus:ring-accent-primary focus:border-accent-primary"
                        />
                        <button
                            onClick={handleAddBodyweightEntry}
                            class="bg-accent-primary hover:bg-accent-primary-dark text-button-text font-semibold py-2 px-4 rounded-md text-sm flex-shrink-0 transition-colors" // Adjusted to use text-button-text for text color
                        >
                            Log Entry
                        </button>
                    </div>
                    {addBodyweightMessage.text && (
                        <div class={`text-xs mt-2 ${
                            addBodyweightMessage.type === 'error' ? 'text-error' : 
                            addBodyweightMessage.type === 'success' ? 'text-success' : 'text-warning' // Assuming text-warning class exists for warnings
                        }`}>
                            {addBodyweightMessage.text}
                        </div>
                    )}
                    {/* TODO: Could add a link here to view full bodyweight history if you build that page */}
                </div>
            </div>

            {/* Notifications Section */}
            <div>
                <h3 class="text-xs uppercase text-secondary font-semibold mb-2 px-4 sm:px-0">Notifications</h3>
                <List class="bg-secondary rounded-md border border-border-primary p-0">
                    <SettingsItem
                        icon={Bell}
                        primary="Personal Best Notifications"
                        secondary={config.pb_notifications.enabled === null ? "Prompt on first PB" : (config.pb_notifications.enabled ? "Enabled" : "Disabled")}
                        actionComponent={
                            <Switch
                                class="scale-75"
                                checked={config.pb_notifications.enabled === true}
                                onChange={() => handleSettingChange('set_pb_notification_enabled', { enabled: config.pb_notifications.enabled !== true },
                                    (prev, payload) => ({
                                        ...prev,
                                        pb_notifications: {...prev.pb_notifications, enabled: payload.enabled }
                                    })
                                )}
                            />
                        }
                    />
                    {config.pb_notifications.enabled !== null && (
                        <>
                            <SettingsItem
                                icon={Weight} primary="Notify for Weight PBs" className="!pl-12"
                                actionComponent={<Switch class="scale-75" checked={config.pb_notifications.notify_weight} onChange={() => handleSettingChange('set_pb_notify_weight', { enabled: !config.pb_notifications.notify_weight }, (prev, p) => ({...prev, pb_notifications: {...prev.pb_notifications, notify_weight: p.enabled}}))} />}
                            />
                            <SettingsItem
                                icon={Repeat} primary="Notify for Reps PBs" className="!pl-12"
                                actionComponent={<Switch class="scale-75" checked={config.pb_notifications.notify_reps} onChange={() => handleSettingChange('set_pb_notify_reps', { enabled: !config.pb_notifications.notify_reps }, (prev, p) => ({...prev, pb_notifications: {...prev.pb_notifications, notify_reps: p.enabled}}))} />}
                            />
                            <SettingsItem
                                icon={Clock} primary="Notify for Duration PBs" className="!pl-12"
                                actionComponent={<Switch class="scale-75" checked={config.pb_notifications.notify_duration} onChange={() => handleSettingChange('set_pb_notify_duration', { enabled: !config.pb_notifications.notify_duration }, (prev, p) => ({...prev, pb_notifications: {...prev.pb_notifications, notify_duration: p.enabled}}))} />}
                            />
                             <SettingsItem
                                icon={Route} primary="Notify for Distance PBs" className="!pl-12"
                                actionComponent={<Switch class="scale-75" checked={config.pb_notifications.notify_distance} onChange={() => handleSettingChange('set_pb_notify_distance', { enabled: !config.pb_notifications.notify_distance }, (prev, p) => ({...prev, pb_notifications: {...prev.pb_notifications, notify_distance: p.enabled}}))} />}
                            />
                        </>
                    )}
                </List>
            </div>

            {/* Support Section */}
            <div>
                <h3 class="text-xs uppercase text-secondary font-semibold mb-2 px-4 sm:px-0">Support</h3>
                 <List class="bg-secondary rounded-md border border-border-primary p-0">
                    <SettingsItem icon={HelpCircle} primary="Help & FAQ" onClick={() => alert("Help & FAQ clicked (not implemented)")} />
                    <SettingsItem icon={Heart} primary="Rate App" onClick={() => alert("Rate App clicked (not implemented)")} />
                 </List>
            </div>
       </div>
    </div>
  );
};

export default Profile;


// src/pages/Stats.tsx
// src/components/Stats/Stats.tsx (or your actual path)
import { h } from 'preact';
import { useState, useEffect, useRef } from 'preact/hooks';
import { invoke } from '@tauri-apps/api/core';
import * as d3 from 'd3';
import { ListChecks, Target, Timer } from 'lucide-preact';

// Define types based on your Rust structs (ensure they are accurate)
interface ExerciseDefinition {
  id: number;
  name: string;
  type: string;
  muscles: string | null;
  log_weight: boolean;
  log_reps: boolean;
  log_duration: boolean;
  log_distance: boolean;
}

type ChartDataPointFromBackend = [string, number]; // [YYYY-MM-DD, value]
type ParsedChartDataPoint = { date: Date; value: number };

// --- New Types for Exercise Stats ---
interface PersonalBestsStats {
  max_weight: number | null;
  max_reps: number | null;
  max_duration_minutes: number | null;
  max_distance_km: number | null; // Backend sends km
}

interface ExerciseStatsData {
  canonical_name: string;
  total_workouts: number;
  first_workout_date: string | null; // YYYY-MM-DD
  last_workout_date: string | null; // YYYY-MM-DD
  avg_workouts_per_week: number | null;
  longest_gap_days: number | null;
  personal_bests: PersonalBestsStats;
  current_streak: number;
  longest_streak: number;
  streak_interval_days: number;
}

interface AppConfig {
    units: 'metric' | 'imperial';
    // Add other config fields if needed for display
}
// --- End New Types ---


const graphTypeOptions = [
  { value: 'Estimated1RM', label: 'Est. 1 Rep Max' },
  { value: 'MaxWeight', label: 'Max Weight Lifted' },
  { value: 'MaxReps', label: 'Max Reps (at any weight)' },
  { value: 'WorkoutVolume', label: 'Total Volume' },
  { value: 'WorkoutReps', label: 'Total Reps' },
  { value: 'WorkoutDuration', label: 'Total Duration (min)' },
  { value: 'WorkoutDistance', label: 'Total Distance' },
];

const timeFrameOptions = [
  { id: 'all', label: 'All Time' },
  { id: 'ytd', label: 'Year to Date' },
  { id: 'last_year', label: 'Last 12 Months' },
  { id: 'last_90d', label: 'Last 90 Days' },
  { id: 'last_30d', label: 'Last 30 Days' },
];

const getTimeFrameDates = (timeFrameId: string): { startDate?: string; endDate?: string } => {
  const today = new Date();
  const endDate = today.toISOString().split('T')[0];

  switch (timeFrameId) {
    case 'ytd':
      return { startDate: `${today.getFullYear()}-01-01`, endDate };
    case 'last_year': {
      const oneYearAgo = new Date(today);
      oneYearAgo.setFullYear(today.getFullYear() - 1);
      oneYearAgo.setDate(oneYearAgo.getDate() + 1); // Correctly make it exactly 12 months
      return { startDate: oneYearAgo.toISOString().split('T')[0], endDate };
    }
    case 'last_90d': {
      const ninetyDaysAgo = new Date(today);
      ninetyDaysAgo.setDate(today.getDate() - 89); // today - 89 days = 90 distinct days including today
      return { startDate: ninetyDaysAgo.toISOString().split('T')[0], endDate };
    }
    case 'last_30d': {
      const thirtyDaysAgo = new Date(today);
      thirtyDaysAgo.setDate(today.getDate() - 29); // today - 29 days = 30 distinct days including today
      return { startDate: thirtyDaysAgo.toISOString().split('T')[0], endDate };
    }
    case 'all':
    default:
      return { startDate: undefined, endDate: undefined };
  }
};

interface D3ChartProps {
  data: ParsedChartDataPoint[];
  graphMetricType: string;
  chartId: string;
}

const D3ChartComponent = ({ data, graphMetricType, chartId }: D3ChartProps) => {
  const svgRef = useRef<SVGSVGElement | null>(null);
  const tooltipRef = useRef<HTMLDivElement | null>(null);

  useEffect(() => {
    if (!svgRef.current || !tooltipRef.current) return;

    const svg = d3.select(svgRef.current);
    const tooltip = d3.select(tooltipRef.current);

    svg.selectAll("*").remove();

    const parentElement = svgRef.current.parentElement;
    if (!parentElement) return;

    const parentWidth = parentElement.clientWidth;
    const parentHeight = parentElement.clientHeight;

    const styles = getComputedStyle(document.documentElement);
    const textColorMuted = styles.getPropertyValue('--color-text-muted').trim() || '#9ca3af';
    const textColorSubtle = styles.getPropertyValue('--color-text-subtle').trim() || '#6b7280';
    const borderColorStrong = styles.getPropertyValue('--color-border-strong').trim() || '#d1d5db';
    const accentColor = styles.getPropertyValue('--color-accent-emphasis').trim() || 'steelblue';


    if (data.length === 0) {
      svg.attr('width', parentWidth).attr('height', parentHeight);
      svg.append("text")
        .attr("x", parentWidth / 2)
        .attr("y", parentHeight / 2)
        .attr("text-anchor", "middle")
        .attr("dominant-baseline", "middle")
        .style("font-size", "16px")
        .style("font-family", "inherit")
        .style("fill", textColorMuted)
        .text("No data available for this selection.");
      return;
    }

    const margin = { top: 20, right: 30, bottom: 60, left: 60 };
    const width = parentWidth - margin.left - margin.right;
    const height = parentHeight - margin.top - margin.bottom;

    if (width <= 0 || height <= 0) return;

    svg
      .attr("width", width + margin.left + margin.right)
      .attr("height", height + margin.top + margin.bottom);

    const chartRoot = svg.append("g")
      .attr("transform", `translate(${margin.left},${margin.top})`);

    const xScale = d3.scaleTime()
      .domain(d3.extent(data, d => d.date) as [Date, Date])
      .range([0, width]);

    const yScale = d3.scaleLinear()
      .domain([0, (d3.max(data, d => d.value) as number) * 1.1])
      .nice()
      .range([height, 0]);

    chartRoot.append("g")
      .attr("transform", `translate(0,${height})`)
      .call(d3.axisBottom(xScale).ticks(Math.min(data.length, 5)).tickFormat(d3.timeFormat("%b %d '%y")))
      .attr("font-family", "inherit")
      .call(g => g.select(".domain").attr("stroke", borderColorStrong))
      .call(g => g.selectAll(".tick line").attr("stroke", textColorSubtle))
      .call(g => g.selectAll(".tick text").attr("fill", textColorSubtle)
        .style("text-anchor", "end")
        .attr("dx", "-.8em")
        .attr("dy", ".15em")
        .attr("transform", "rotate(-40)"));

    chartRoot.append("g")
      .call(d3.axisLeft(yScale).ticks(5).tickFormat(d3.format(".2~s")))
      .attr("font-family", "inherit")
      .call(g => g.select(".domain").attr("stroke", borderColorStrong))
      .call(g => g.selectAll(".tick line").attr("stroke", textColorSubtle))
      .call(g => g.selectAll(".tick text").attr("fill", textColorSubtle));

    const line = d3.line<ParsedChartDataPoint>()
      .x(d => xScale(d.date))
      .y(d => yScale(d.value))
      .curve(d3.curveMonotoneX);

    chartRoot.append("path")
      .datum(data)
      .attr("fill", "none")
      .attr("stroke", accentColor)
      .attr("stroke-width", 2)
      .attr("d", line);

    chartRoot.selectAll(".dot")
      .data(data)
      .enter().append("circle")
        .attr("class", "dot")
        .attr("cx", d => xScale(d.date))
        .attr("cy", d => yScale(d.value))
        .attr("r", 4)
        .attr("fill", accentColor)
        .on("mouseover", (event, d_event) => {
          tooltip.style("opacity", 0.9)
                 .html(`Date: ${d3.timeFormat("%Y-%m-%d")(d_event.date)}<br/>Value: ${d_event.value.toFixed(2)}`)
                 .style("left", (event.pageX + 15) + "px")
                 .style("top", (event.pageY - 28) + "px");
        })
        .on("mouseout", () => {
          tooltip.style("opacity", 0);
        });

  }, [data, graphMetricType, chartId]);

  return (
    <div class="w-full h-full relative">
      <svg ref={svgRef} class="block w-full h-full"></svg>
      <div
        ref={tooltipRef}
        class="absolute text-center p-2 text-xs bg-[var(--color-text-default)] text-[var(--color-bg-app)] rounded pointer-events-none opacity-0 transition-opacity duration-200"
        id={`tooltip-${chartId}`}
      ></div>
    </div>
  );
};

// --- Helper function for formatting stat values ---
const formatStatValue = (
  value: number | string | null | undefined,
  unitSingular: string = '',
  unitPlural?: string, // Optional: if not provided, unitSingular is used for all numbers
  precision: number = 0
): string => {
  if (value === null || value === undefined) return 'N/A';
  if (typeof value === 'number') {
    const numStr = value.toFixed(precision);
    if (unitSingular) {
      const actualUnit = (value === 1 || value === -1) ? unitSingular : (unitPlural || unitSingular);
      return `${numStr} ${actualUnit}`;
    }
    return numStr;
  }
  return value; // For strings like dates
};


// --- New UI Components for Stats Tables ---
const ExerciseSummaryTable = ({ stats, exerciseName }: { stats: ExerciseStatsData, exerciseName: string }) => {
  const data = [
    { label: 'Total Workouts', value: formatStatValue(stats.total_workouts) },
    { label: 'First Workout', value: formatStatValue(stats.first_workout_date) },
    { label: 'Last Workout', value: formatStatValue(stats.last_workout_date) },
    { label: 'Avg Workouts / Week', value: formatStatValue(stats.avg_workouts_per_week, '', '', 2) }, // No units, precision 2
    { label: 'Longest Gap', value: formatStatValue(stats.longest_gap_days, 'day', 'days') },
    { label: 'Current Streak', value: `${formatStatValue(stats.current_streak)} (Interval: ${stats.streak_interval_days} days)` },
    { label: 'Longest Streak', value: `${formatStatValue(stats.longest_streak)} (Interval: ${stats.streak_interval_days} days)` },
  ];

  return (
    <div class="bg-[var(--color-bg-surface)] p-4 rounded-lg shadow border border-[var(--color-border-subtle)]">
      <h3 class="text-lg font-semibold mb-3 text-[var(--color-text-default)]">Statistics for '{exerciseName}'</h3>
      <div class="overflow-x-auto">
        <table class="w-full text-sm text-left text-[var(--color-text-subtle)]">
          <tbody class="divide-y divide-[var(--color-border-subtle)]">
            {data.map(item => (
              <tr key={item.label}>
                <th scope="row" class="py-2 pr-3 font-medium text-[var(--color-text-default)] whitespace-nowrap">{item.label}</th>
                <td class="py-2 pl-3 text-right whitespace-nowrap">{item.value}</td>
              </tr>
            ))}
          </tbody>
        </table>
      </div>
    </div>
  );
};

const PersonalBestsTable = ({ pbs, exerciseDef, config }: { pbs: PersonalBestsStats, exerciseDef: ExerciseDefinition, config: AppConfig | null }) => {
  const KM_TO_MILE = 0.621371;
  const KG_TO_LBS = 2.20462;

  const displayUnits = config?.units || 'metric';
  const distanceUnitLabel = displayUnits === 'imperial' ? 'mi' : 'km';
  const weightUnitLabel = displayUnits === 'imperial' ? 'lbs' : 'kg';

  const data = [];

  if (exerciseDef.log_weight && pbs.max_weight !== null) {
    let displayWeight = pbs.max_weight;
    if (displayUnits === 'imperial') {
        displayWeight = pbs.max_weight * KG_TO_LBS;
    }
    data.push({ label: 'Max Weight', value: formatStatValue(displayWeight, weightUnitLabel, weightUnitLabel, 2) });
  }
  if (exerciseDef.log_reps && pbs.max_reps !== null) {
    data.push({ label: 'Max Reps', value: formatStatValue(pbs.max_reps) });
  }
  if (exerciseDef.log_duration && pbs.max_duration_minutes !== null) {
    data.push({ label: 'Max Duration', value: formatStatValue(pbs.max_duration_minutes, 'min', 'mins') });
  }
  if (exerciseDef.log_distance && pbs.max_distance_km !== null) {
    let displayDistance = pbs.max_distance_km;
    if (displayUnits === 'imperial') {
        displayDistance = pbs.max_distance_km * KM_TO_MILE;
    }
    data.push({ label: 'Max Distance', value: formatStatValue(displayDistance, distanceUnitLabel, distanceUnitLabel, 2) });
  }

  if (data.length === 0) {
    return (
      <div class="bg-[var(--color-bg-surface)] p-4 rounded-lg shadow border border-[var(--color-border-subtle)]">
        <h3 class="text-lg font-semibold mb-2 text-[var(--color-text-default)]">Personal Bests</h3>
        <p class="text-sm text-[var(--color-text-muted)]">No personal bests applicable or recorded for this exercise.</p>
      </div>
    );
  }

  return (
    <div class="bg-[var(--color-bg-surface)] p-4 rounded-lg shadow border border-[var(--color-border-subtle)]">
      <h3 class="text-lg font-semibold mb-3 text-[var(--color-text-default)]">Personal Bests</h3>
      <div class="overflow-x-auto">
        <table class="w-full text-sm text-left text-[var(--color-text-subtle)]">
          <tbody class="divide-y divide-[var(--color-border-subtle)]">
            {data.map(item => (
              <tr key={item.label}>
                <th scope="row" class="py-2 pr-3 font-medium text-[var(--color-text-default)] whitespace-nowrap">{item.label}</th>
                <td class="py-2 pl-3 text-right whitespace-nowrap">{item.value}</td>
              </tr>
            ))}
          </tbody>
        </table>
      </div>
    </div>
  );
};
// --- End New UI Components ---


const Stats = () => {
  const [exercises, setExercises] = useState<ExerciseDefinition[]>([]);
  const [selectedExerciseId, setSelectedExerciseId] = useState<string | null>(null);
  const [selectedGraphType, setSelectedGraphType] = useState<string>(graphTypeOptions[0].value);
  const [selectedTimeFrame, setSelectedTimeFrame] = useState<string>(timeFrameOptions[0].id);

  const [chartData, setChartData] = useState<ParsedChartDataPoint[] | null>(null);
  const [isLoading, setIsLoading] = useState<boolean>(false);
  const [error, setError] = useState<string | null>(null);

  // --- State for Exercise Stats ---
  const [exerciseStats, setExerciseStats] = useState<ExerciseStatsData | null>(null);
  const [isStatsLoading, setIsStatsLoading] = useState<boolean>(false);
  const [statsError, setStatsError] = useState<string | null>(null);
  const [appConfig, setAppConfig] = useState<AppConfig | null>(null);
  // --- End State for Exercise Stats ---

  useEffect(() => {
    const fetchInitialData = async () => {
      setIsLoading(true); // Combined loading for exercises and initial chart
      try {
        // Fetch exercises
        const fetchedExercises: ExerciseDefinition[] = await invoke('list_exercises', {});
        setExercises(fetchedExercises);
        if (fetchedExercises.length > 0) {
          // Automatically select the first exercise
          const firstExId = fetchedExercises[0].id.toString();
          setSelectedExerciseId(firstExId);
        } else {
          setIsLoading(false); // No exercises, stop loading
        }

        // Fetch app config
        const config: AppConfig = await invoke('get_config');
        setAppConfig(config);

      } catch (err) {
        console.error("Failed to fetch initial data:", err);
        setError("Failed to load initial page data.");
        setIsLoading(false);
      }
      // setIsLoading(false) will be handled by chart data fetch if exercises exist
    };
    fetchInitialData();
  }, []);

  useEffect(() => {
    if (!selectedExerciseId) {
      setChartData(null);
      setExerciseStats(null); // Clear stats if no exercise selected
      return;
    }

    const fetchChartData = async () => {
      setIsLoading(true);
      setError(null);
      try {
        const { startDate, endDate } = getTimeFrameDates(selectedTimeFrame);
        const graphPayloadData = {
          identifier: selectedExerciseId,
          graphTypeStr: selectedGraphType,
          startDate: startDate,
          endDate: endDate,
        };
        const invokeArgs = { payload: graphPayloadData };
        const rawData: ChartDataPointFromBackend[] = await invoke('get_data_for_graph', invokeArgs);
        const parsedData: ParsedChartDataPoint[] = rawData
          .map(d => {
            const dateObj = d3.timeParse("%Y-%m-%d")(d[0]);
            return dateObj ? { date: dateObj, value: d[1] } : null;
          })
          .filter(d => d !== null) as ParsedChartDataPoint[];
        parsedData.sort((a, b) => a.date.getTime() - b.date.getTime());
        setChartData(parsedData);
      } catch (err: any) {
        console.error("Failed to fetch chart data:", err);
        setError(err.message || err.toString() || "Failed to load chart data.");
        setChartData(null);
      } finally {
        setIsLoading(false);
      }
    };

    const fetchExerciseStats = async () => {
        setIsStatsLoading(true);
        setStatsError(null);
        try {
            const stats: ExerciseStatsData = await invoke('get_exercise_stats', { identifier: selectedExerciseId });
            setExerciseStats(stats);
        } catch (err: any) {
            console.error("Failed to fetch exercise stats:", err);
            setStatsError(err.message || err.toString() || "Failed to load exercise statistics.");
            setExerciseStats(null);
        } finally {
            setIsStatsLoading(false);
        }
    };

    if (selectedGraphType) fetchChartData(); // Fetch chart data if graph type is also selected
    fetchExerciseStats(); // Always fetch stats for the selected exercise

  }, [selectedExerciseId, selectedGraphType, selectedTimeFrame]);

  const MetricCard = ({ title, value, icon: Icon }: {title: string, value: string | JSX.Element, icon: any}) => (
    <div class="bg-[var(--color-bg-surface)] p-4 rounded-md border border-[var(--color-border-subtle)] shadow-sm flex-shrink-0 w-full sm:w-auto sm:flex-grow">
        <div class="flex items-center justify-between mb-1">
            <h3 class="text-sm font-medium text-[var(--color-text-subtle)]">{title}</h3>
             {Icon && <Icon class="w-5 h-5 text-[var(--color-text-default)]" strokeWidth={2} />}
        </div>
        <p class="text-lg font-semibold text-[var(--color-text-default)]">{value}</p>
    </div>
  );

  const selectedExerciseDefinition = exercises.find(ex => ex.id.toString() === selectedExerciseId);

  return (
    <div class="flex flex-col h-full p-4 space-y-6 bg-[var(--color-bg-app)] text-[var(--color-text-default)]">
      {/* Chart Controls */}
      <div class="grid grid-cols-1 md:grid-cols-3 gap-4 items-end p-4 bg-[var(--color-bg-surface)] rounded-lg shadow">
        <div>
          <label htmlFor="exercise-select" class="block text-sm font-medium text-[var(--color-text-default)] mb-1">Exercise</label>
          <select
            id="exercise-select"
            class="mt-1 block w-full pl-3 pr-10 py-2 text-base bg-[var(--color-bg-surface)] text-[var(--color-text-default)] border border-[var(--color-border-subtle)] focus:outline-none focus:ring-2 focus:ring-[var(--color-accent-subtle-bg)] focus:border-[var(--color-accent-emphasis)] sm:text-sm rounded-md shadow-sm"
            value={selectedExerciseId || ''}
            onChange={(e) => setSelectedExerciseId((e.target as HTMLSelectElement).value)}
            disabled={exercises.length === 0 && isLoading} // Disable only if loading and no exercises yet
          >
            {exercises.length === 0 && <option value="" disabled class="text-[var(--color-text-muted)]">{isLoading ? "Loading exercises..." : "No exercises found"}</option>}
            {exercises.map((ex) => (
              <option key={ex.id} value={ex.id.toString()}>{ex.name}</option>
            ))}
          </select>
        </div>

        <div>
          <label htmlFor="graph-type-select" class="block text-sm font-medium text-[var(--color-text-default)] mb-1">Metric to Display</label>
          <select
            id="graph-type-select"
            class="mt-1 block w-full pl-3 pr-10 py-2 text-base bg-[var(--color-bg-surface)] text-[var(--color-text-default)] border border-[var(--color-border-subtle)] focus:outline-none focus:ring-2 focus:ring-[var(--color-accent-subtle-bg)] focus:border-[var(--color-accent-emphasis)] sm:text-sm rounded-md shadow-sm"
            value={selectedGraphType}
            onChange={(e) => setSelectedGraphType((e.target as HTMLSelectElement).value)}
            disabled={!selectedExerciseId}
          >
            {graphTypeOptions.map((gt) => (
              <option key={gt.value} value={gt.value}>{gt.label}</option>
            ))}
          </select>
        </div>

        <div>
            <label htmlFor="timeframe-select" class="block text-sm font-medium text-[var(--color-text-default)] mb-1">Time Frame</label>
            <select
                id="timeframe-select"
                class="mt-1 block w-full pl-3 pr-10 py-2 text-base bg-[var(--color-bg-surface)] text-[var(--color-text-default)] border border-[var(--color-border-subtle)] focus:outline-none focus:ring-2 focus:ring-[var(--color-accent-subtle-bg)] focus:border-[var(--color-accent-emphasis)] sm:text-sm rounded-md shadow-sm"
                value={selectedTimeFrame}
                onChange={(e) => setSelectedTimeFrame((e.target as HTMLSelectElement).value)}
                disabled={!selectedExerciseId}
            >
                {timeFrameOptions.map((tf) => (
                    <option key={tf.id} value={tf.id}>{tf.label}</option>
                ))}
            </select>
        </div>
      </div>

      {/* Chart Display Area */}
      <div class="flex-grow bg-[var(--color-bg-surface)] p-2 rounded-lg shadow-lg border border-[var(--color-border-subtle)] min-h-[350px] md:min-h-[450px] relative">
        {isLoading && selectedExerciseId && ( // Show loading only if an exercise is selected and chart data is loading
          <div class="absolute inset-0 flex items-center justify-center bg-[var(--color-bg-surface)]/75 z-10 rounded-lg">
            <p class="text-lg text-[var(--color-accent-emphasis)]">Loading chart data...</p>
          </div>
        )}
        {error && !isLoading && selectedExerciseId && (
          <div class="absolute inset-0 flex flex-col items-center justify-center text-[var(--color-accent-destructive)] p-4 rounded-lg">
            <p class="font-semibold">Error loading chart:</p>
            <p class="text-sm text-center">{error}</p>
          </div>
        )}
        {!isLoading && !error && chartData && selectedExerciseId && chartData.length > 0 && ( // Ensure chartData is not null and has items
             <D3ChartComponent
                data={chartData}
                graphMetricType={selectedGraphType}
                chartId={`exercise-chart-${selectedExerciseId}-${selectedGraphType}`}
            />
        )}
         {/* Show "No data to display" only if not loading, no error, but chartData is empty or null for a selected exercise */}
         {!isLoading && !error && selectedExerciseId && (!chartData || chartData.length === 0) && (
            <div class="absolute inset-0 flex items-center justify-center text-[var(--color-text-muted)]">
                <p>No data to display for the current chart selection.</p>
            </div>
        )}
        {!selectedExerciseId && !isLoading && ( // If no exercise is selected and not in initial load
            <div class="absolute inset-0 flex items-center justify-center text-[var(--color-text-muted)]">
                <p>Select an exercise to view stats and chart.</p>
            </div>
        )}
      </div>

      {/* --- Exercise Statistics and Personal Bests Section --- */}
      {selectedExerciseId && ( // Only show this section if an exercise is selected
        <div class="mt-0"> {/* Adjusted margin if needed, space-y-6 on parent handles overall spacing */}
          {isStatsLoading && (
            <div class="py-4 text-center text-[var(--color-text-muted)]">Loading statistics...</div>
          )}
          {statsError && !isStatsLoading && (
            <div class="p-4 bg-[var(--color-bg-destructive-subtle)] border border-[var(--color-border-destructive)] text-[var(--color-text-destructive)] rounded-md">
              <p class="font-semibold">Error loading exercise statistics:</p>
              <p class="text-sm">{statsError}</p>
            </div>
          )}
          {!isStatsLoading && !statsError && exerciseStats && selectedExerciseDefinition && appConfig && (
            <div class="grid grid-cols-1 lg:grid-cols-2 gap-6">
              <ExerciseSummaryTable stats={exerciseStats} exerciseName={exerciseStats.canonical_name} />
              <PersonalBestsTable pbs={exerciseStats.personal_bests} exerciseDef={selectedExerciseDefinition} config={appConfig} />
            </div>
          )}
          {/* Case: No stats found for a selected exercise (e.g., new exercise with no workouts) */}
          {!isStatsLoading && !statsError && !exerciseStats && selectedExerciseId && (
            <div class="py-4 text-center text-[var(--color-text-muted)]">
                No statistics recorded for '{selectedExerciseDefinition?.name || 'this exercise'}'.
            </div>
          )}
        </div>
      )}
    </div>
  );
};

export default Stats;


// src-tauri/build.rs
fn main() {
    tauri_build::build()
}


// src-tauri/src/lib.rs
use chrono::{DateTime, NaiveDate, Utc};
use serde::Deserialize; // Serialize might be needed if any local structs are returned
use std::sync::{Arc, Mutex};
// For HashMap in list_aliases, though often implicitly available via std prelude
// use std::collections::HashMap; // Explicit import not strictly necessary for HashMap usually

// Import your library crate - assuming the name is task_athlete_lib
use task_athlete_lib::{
    AddWorkoutParams,
    AppService,
    Config,
    // ConfigError, // Handled as String
    // DbError, // Handled as String
    EditWorkoutParams,
    ExerciseDefinition,
    ExerciseStats,
    ExerciseType,
    GraphType,
    PBInfo,
    PersonalBests,
    Units,
    VolumeFilters,
    Workout,
    WorkoutFilters,
};

// Type alias for the shared state
type AppState = Arc<Mutex<AppService>>;

// --- Command Input Structs ---
#[derive(Deserialize)]
struct AddWorkoutCmdParams {
    pub exercise_identifier: String,
    pub date: Option<String>,
    pub sets: Option<i64>,
    pub reps: Option<i64>,
    pub weight: Option<f64>,
    pub duration: Option<i64>,
    pub distance: Option<f64>,
    pub notes: Option<String>,
    pub implicit_type: Option<String>,
    pub implicit_muscles: Option<String>,
    pub bodyweight_to_use: Option<f64>,
}

#[derive(Deserialize)]
struct GetDataForGraphPayload {
    identifier: String,
    #[serde(alias = "graphTypeStr")]
    graph_type_str: String,
    start_date: Option<String>,
    end_date: Option<String>,
}

#[derive(Deserialize)]
struct SetUnitsPayload {
    units: String,
}

#[derive(Deserialize)]
struct MonthYearQuery {
    year: i32,
    month: u32,
}

#[derive(Deserialize)]
struct EditWorkoutCmdParams {
    pub id: i64,
    pub new_exercise_identifier: Option<String>,
    pub new_sets: Option<i64>,
    pub new_reps: Option<i64>,
    pub new_weight: Option<f64>,
    pub new_bodyweight: Option<f64>,
    pub new_duration: Option<i64>,
    pub new_distance_arg: Option<f64>,
    pub new_notes: Option<String>,
    pub new_date: Option<String>,
}

#[derive(Deserialize, Default)]
struct WorkoutFiltersCmdParams {
    pub exercise_name: Option<String>,
    pub date: Option<String>,
    pub exercise_type: Option<String>,
    pub muscle: Option<String>,
    pub limit: Option<u32>,
}

#[derive(Deserialize, Default)]
struct VolumeFiltersCmdParams {
    pub exercise_name: Option<String>,
    pub start_date: Option<String>,
    pub end_date: Option<String>,
    pub exercise_type: Option<String>,
    pub muscle: Option<String>,
    pub limit_days: Option<u32>,
}

#[derive(Deserialize)]
struct GetPreviousWorkoutDetailsPayload {
    identifier: String,
    n: u32,
}

// --- Helper Functions ---
fn parse_naive_date(date_str: &str) -> Result<NaiveDate, String> {
    NaiveDate::parse_from_str(date_str, "%Y-%m-%d")
        .map_err(|e| format!("Invalid date format '{}': {}", date_str, e))
}

fn parse_datetime(date_str: &str) -> Result<DateTime<Utc>, String> {
    DateTime::parse_from_rfc3339(date_str)
        .map(|dt| dt.with_timezone(&Utc))
        .map_err(|e| format!("Invalid timestamp format '{}': {}", date_str, e))
}

fn parse_exercise_type(type_str: &str) -> Result<ExerciseType, String> {
    ExerciseType::try_from(type_str)
        .map_err(|e| format!("Invalid exercise type string: {} ({})", type_str, e))
}

// --- Tauri Commands ---

// From your initial lib.rs snippet
#[tauri::command]
fn greet(name: &str) -> String {
    format!("Hello, {}! You've been greeted from Rust!", name)
}

#[tauri::command]
fn get_config(state: tauri::State<'_, AppState>) -> Result<Config, String> {
    let service = state
        .lock()
        .map_err(|e| format!("Failed to lock state: {}", e))?;
    Ok(service.config.clone())
}

#[tauri::command]
fn save_config(state: tauri::State<'_, AppState>) -> Result<(), String> {
    let service = state
        .lock()
        .map_err(|e| format!("Failed to lock state: {}", e))?;
    service.save_config().map_err(|e| e.to_string())
}

#[tauri::command]
fn set_bodyweight(weight: f64, state: tauri::State<'_, AppState>) -> Result<(), String> {
    let mut service = state
        .lock()
        .map_err(|e| format!("Failed to lock state: {}", e))?;
    service.set_bodyweight(weight).map_err(|e| e.to_string())
}

#[tauri::command]
fn list_workouts(
    filters: WorkoutFiltersCmdParams,
    state: tauri::State<'_, AppState>,
) -> Result<Vec<Workout>, String> {
    let service = state
        .lock()
        .map_err(|e| format!("Failed to lock state: {}", e))?;
    let lib_filters = WorkoutFilters {
        exercise_name: filters.exercise_name.as_deref(),
        date: filters.date.map(|s| parse_naive_date(&s)).transpose()?,
        exercise_type: filters
            .exercise_type
            .map(|s| parse_exercise_type(&s))
            .transpose()?,
        muscle: filters.muscle.as_deref(),
        limit: filters.limit,
    };
    service
        .list_workouts(&lib_filters)
        .map_err(|e| e.to_string())
}

#[tauri::command]
async fn get_workout_dates_for_month(
    query: MonthYearQuery,
    state: tauri::State<'_, AppState>,
) -> Result<Vec<String>, String> {
    let service = state.lock().map_err(|e| {
        format!(
            "Failed to lock state for get_workout_dates_for_month: {}",
            e
        )
    })?;
    service
        .get_workout_dates_for_month(query.year, query.month)
        .map_err(|e| format!("Error fetching workout dates from lib: {}", e))
}

#[tauri::command]
fn add_workout(
    params: AddWorkoutCmdParams,
    state: tauri::State<'_, AppState>,
) -> Result<(i64, Option<PBInfo>), String> {
    let mut service = state
        .lock()
        .map_err(|e| format!("Failed to lock state: {}", e))?;
    let date = match params.date {
        Some(date_str) => parse_datetime(&date_str)?,
        None => Utc::now(),
    };
    let implicit_type = params
        .implicit_type
        .map(|s| parse_exercise_type(&s))
        .transpose()?;
    let lib_params = AddWorkoutParams {
        exercise_identifier: &params.exercise_identifier,
        date,
        sets: params.sets,
        reps: params.reps,
        weight: params.weight,
        duration: params.duration,
        distance: params.distance,
        notes: params.notes,
        implicit_type,
        implicit_muscles: params.implicit_muscles,
        bodyweight_to_use: params.bodyweight_to_use,
    };
    service.add_workout(lib_params).map_err(|e| e.to_string())
}

#[tauri::command]
fn edit_workout(
    params: EditWorkoutCmdParams,
    state: tauri::State<'_, AppState>,
) -> Result<u64, String> {
    let service = state
        .lock()
        .map_err(|e| format!("Failed to lock state: {}", e))?;
    let lib_params = EditWorkoutParams {
        id: params.id,
        new_exercise_identifier: params.new_exercise_identifier,
        new_sets: params.new_sets,
        new_reps: params.new_reps,
        new_weight: params.new_weight,
        new_bodyweight: params.new_bodyweight,
        new_duration: params.new_duration,
        new_distance_arg: params.new_distance_arg,
        new_notes: params.new_notes,
        new_date: params.new_date.map(|s| parse_naive_date(&s)).transpose()?,
    };
    service.edit_workout(lib_params).map_err(|e| e.to_string())
}

#[tauri::command]
fn delete_workouts(ids: Vec<i64>, state: tauri::State<'_, AppState>) -> Result<Vec<i64>, String> {
    let service = state
        .lock()
        .map_err(|e| format!("Failed to lock state: {}", e))?;
    service.delete_workouts(&ids).map_err(|e| e.to_string())
}

#[tauri::command]
fn list_exercises(
    type_filter_str: Option<String>,
    muscles_filter: Option<Vec<String>>,
    state: tauri::State<'_, AppState>,
) -> Result<Vec<ExerciseDefinition>, String> {
    let muscle_refs: Option<Vec<&str>> = muscles_filter
        .as_ref()
        .map(|m| m.iter().map(|s| s.as_str()).collect());
    let service = state
        .lock()
        .map_err(|e| format!("Failed to lock state: {}", e))?;
    let type_filter = type_filter_str
        .map(|s| parse_exercise_type(&s))
        .transpose()?;
    service
        .list_exercises(type_filter, muscle_refs)
        .map_err(|e| e.to_string())
}

#[tauri::command]
fn create_exercise(
    name: String,
    type_str: String,
    muscles: Option<String>,
    log_weight: Option<bool>,
    log_reps: Option<bool>,
    log_duration: Option<bool>,
    log_distance: Option<bool>,
    state: tauri::State<'_, AppState>,
) -> Result<i64, String> {
    let service = state
        .lock()
        .map_err(|e| format!("Failed to lock state: {}", e))?;
    let ex_type = parse_exercise_type(&type_str)?;
    let log_flags = Some((log_weight, log_reps, log_duration, log_distance));
    service
        .create_exercise(&name, ex_type, log_flags, muscles.as_deref())
        .map_err(|e| e.to_string())
}

#[tauri::command]
fn edit_exercise(
    identifier: String,
    new_name: Option<String>,
    new_type_str: Option<String>,
    new_muscles: Option<Option<String>>,
    log_weight: Option<bool>,
    log_reps: Option<bool>,
    log_duration: Option<bool>,
    log_distance: Option<bool>,
    state: tauri::State<'_, AppState>,
) -> Result<u64, String> {
    let mut service = state
        .lock()
        .map_err(|e| format!("Failed to lock state: {}", e))?;
    let new_type = new_type_str.map(|s| parse_exercise_type(&s)).transpose()?;
    let new_muscles_ref = new_muscles.as_ref().map(|opt_s| opt_s.as_deref());
    let log_flags = Some((log_weight, log_reps, log_duration, log_distance));
    service
        .edit_exercise(
            &identifier,
            new_name.as_deref(),
            new_type,
            log_flags,
            new_muscles_ref,
        )
        .map_err(|e| e.to_string())
}

#[tauri::command]
fn delete_exercise(
    identifiers: Vec<String>,
    state: tauri::State<'_, AppState>,
) -> Result<u64, String> {
    let mut service = state
        .lock()
        .map_err(|e| format!("Failed to lock state: {}", e))?;
    service
        .delete_exercise(&identifiers)
        .map_err(|e| e.to_string())
}

#[tauri::command]
fn get_exercise_stats(
    identifier: String,
    state: tauri::State<'_, AppState>,
) -> Result<ExerciseStats, String> {
    let service = state
        .lock()
        .map_err(|e| format!("Failed to lock state: {}", e))?;
    service
        .get_exercise_stats(&identifier)
        .map_err(|e| e.to_string())
}

#[tauri::command]
fn get_data_for_graph(
    payload: GetDataForGraphPayload,
    state: tauri::State<'_, AppState>,
) -> Result<Vec<(NaiveDate, f64)>, String> {
    let service = state
        .lock()
        .map_err(|e| format!("Failed to lock state: {}", e))?;
    let graph_type = match payload.graph_type_str.as_str() {
        "Estimated1RM" => GraphType::Estimated1RM,
        "MaxWeight" => GraphType::MaxWeight,
        "MaxReps" => GraphType::MaxReps,
        "WorkoutVolume" => GraphType::WorkoutVolume,
        "WorkoutReps" => GraphType::WorkoutReps,
        "WorkoutDuration" => GraphType::WorkoutDuration,
        "WorkoutDistance" => GraphType::WorkoutDistance,
        _ => return Err(format!("Invalid graph type: {}", payload.graph_type_str)),
    };
    let start_date_filter = payload
        .start_date
        .map(|s| parse_naive_date(&s))
        .transpose()?;
    let end_date_filter = payload.end_date.map(|s| parse_naive_date(&s)).transpose()?;
    service
        .get_data_for_graph(
            &payload.identifier,
            graph_type,
            start_date_filter,
            end_date_filter,
        )
        .map_err(|e| e.to_string())
}

#[tauri::command]
fn list_aliases(
    state: tauri::State<'_, AppState>,
) -> Result<std::collections::HashMap<String, String>, String> {
    let service = state
        .lock()
        .map_err(|e| format!("Failed to lock state: {}", e))?;
    service.list_aliases().map_err(|e| e.to_string())
}

#[tauri::command]
fn create_alias(
    alias_name: String,
    exercise_identifier: String,
    state: tauri::State<'_, AppState>,
) -> Result<(), String> {
    let service = state
        .lock()
        .map_err(|e| format!("Failed to lock state: {}", e))?;
    service
        .create_alias(&alias_name, &exercise_identifier)
        .map_err(|e| e.to_string())
}

#[tauri::command]
fn delete_alias(alias_name: String, state: tauri::State<'_, AppState>) -> Result<u64, String> {
    let service = state
        .lock()
        .map_err(|e| format!("Failed to lock state: {}", e))?;
    service.delete_alias(&alias_name).map_err(|e| e.to_string())
}

#[tauri::command]
fn get_previous_workout_details(
    payload: GetPreviousWorkoutDetailsPayload,
    state: tauri::State<'_, AppState>,
) -> Result<Vec<Workout>, String> {
    let service = state.lock().map_err(|e| {
        format!(
            "Failed to lock state for get_previous_workout_details: {}",
            e
        )
    })?;
    if payload.n == 0 {
        return Err("n must be greater than 0 for get_previous_workout_details".to_string());
    }
    service
        .list_workouts_for_exercise_on_nth_last_day(&payload.identifier, payload.n)
        .map_err(|e| e.to_string())
}

#[tauri::command]
fn list_all_muscles(state: tauri::State<'_, AppState>) -> Result<Vec<String>, String> {
    let service = state
        .lock()
        .map_err(|e| format!("Failed to lock state for list_all_muscles: {}", e))?;
    service
        .list_all_muscles()
        .map_err(|e| format!("Error fetching all muscles from lib: {}", e))
}

#[tauri::command]
fn set_units(payload: SetUnitsPayload, state: tauri::State<'_, AppState>) -> Result<(), String> {
    let mut service = state
        .lock()
        .map_err(|e| format!("Failed to lock state: {}", e))?;
    let units_enum = match payload.units.to_lowercase().as_str() {
        "metric" => Units::Metric,
        "imperial" => Units::Imperial,
        _ => return Err(format!("Invalid units string: {}", payload.units)),
    };
    service.set_units(units_enum).map_err(|e| e.to_string())
}

#[tauri::command]
fn set_streak_interval(days: u32, state: tauri::State<'_, AppState>) -> Result<(), String> {
    let mut service = state
        .lock()
        .map_err(|e| format!("Failed to lock state: {}", e))?;
    service.set_streak_interval(days).map_err(|e| e.to_string())
}

#[tauri::command]
fn set_pb_notification_enabled(
    enabled: bool,
    state: tauri::State<'_, AppState>,
) -> Result<(), String> {
    let mut service = state
        .lock()
        .map_err(|e| format!("Failed to lock state: {}", e))?;
    service
        .set_pb_notification_enabled(enabled)
        .map_err(|e| e.to_string())
}

#[tauri::command]
fn set_pb_notify_weight(enabled: bool, state: tauri::State<'_, AppState>) -> Result<(), String> {
    let mut service = state
        .lock()
        .map_err(|e| format!("Failed to lock state: {}", e))?;
    service
        .set_pb_notify_weight(enabled)
        .map_err(|e| e.to_string())
}

#[tauri::command]
fn set_pb_notify_reps(enabled: bool, state: tauri::State<'_, AppState>) -> Result<(), String> {
    let mut service = state
        .lock()
        .map_err(|e| format!("Failed to lock state: {}", e))?;
    service
        .set_pb_notify_reps(enabled)
        .map_err(|e| e.to_string())
}

#[tauri::command]
fn set_pb_notify_duration(enabled: bool, state: tauri::State<'_, AppState>) -> Result<(), String> {
    let mut service = state
        .lock()
        .map_err(|e| format!("Failed to lock state: {}", e))?;
    service
        .set_pb_notify_duration(enabled)
        .map_err(|e| e.to_string())
}

#[tauri::command]
fn set_pb_notify_distance(enabled: bool, state: tauri::State<'_, AppState>) -> Result<(), String> {
    let mut service = state
        .lock()
        .map_err(|e| format!("Failed to lock state: {}", e))?;
    service
        .set_pb_notify_distance(enabled)
        .map_err(|e| e.to_string())
}

#[tauri::command]
fn set_target_bodyweight(
    weight: Option<f64>,
    state: tauri::State<'_, AppState>,
) -> Result<(), String> {
    let mut service = state
        .lock()
        .map_err(|e| format!("Failed to lock state: {}", e))?;
    service
        .set_target_bodyweight(weight)
        .map_err(|e| e.to_string())
}

#[tauri::command]
fn get_body_weights(
    state: tauri::State<'_, AppState>,
) -> Result<Vec<(i64, DateTime<Utc>, f64)>, String> {
    let mut service = state
        .lock()
        .map_err(|e| format!("Failed to lock state: {}", e))?;
    let bodyweights = service
        .list_bodyweights(u32::MAX)
        .map_err(|e| e.to_string())?;
    Ok(bodyweights)
}

#[tauri::command]
fn add_bodyweight_entry(weight: f64, state: tauri::State<'_, AppState>) -> Result<i64, String> {
    let mut service = state
        .lock()
        .map_err(|e| format!("Failed to lock state for add_bodyweight_entry: {}", e))?;
    let timestamp = Utc::now();
    let entry_id = service
        .add_bodyweight_entry(timestamp, weight)
        .map_err(|e| format!("Failed to add bodyweight entry to log: {}", e.to_string()))?;
    if let Err(e) = service.set_bodyweight(weight) {
        eprintln!(
            "Failed to update current_bodyweight in config after adding new entry: {}",
            e.to_string()
        );
    }
    Ok(entry_id)
}

// Main application entry point function
#[cfg_attr(mobile, tauri::mobile_entry_point)]
pub fn run() {
    let app_service = match task_athlete_lib::AppService::initialize() {
        Ok(service) => {
            println!("AppService initialized successfully.");
            println!("Config Path: {:?}", service.get_config_path());
            println!("DB Path: {:?}", service.get_db_path());
            service
        }
        Err(e) => {
            eprintln!("FATAL: Failed to initialize AppService: {:?}", e);
            // In a real app, you might want to use Tauri's dialog API before exiting
            // tauri::api::dialog::blocking::message(None::<&tauri::Window>, "Initialization Error", format!("Failed to initialize: {}", e));
            std::process::exit(1);
        }
    };

    let app_state: AppState = Arc::new(Mutex::new(app_service));

    tauri::Builder::default()
        .manage(app_state)
        .plugin(tauri_plugin_opener::init()) // Added from your initial lib.rs
        .invoke_handler(tauri::generate_handler![
            greet, // Added from your initial lib.rs
            get_config,
            save_config,
            get_workout_dates_for_month,
            set_bodyweight,
            list_workouts,
            add_workout,
            edit_workout,
            delete_workouts,
            list_exercises,
            create_exercise,
            edit_exercise,
            delete_exercise,
            get_exercise_stats,
            get_data_for_graph,
            list_aliases,
            create_alias,
            delete_alias,
            list_all_muscles,
            set_units,
            get_body_weights,
            // set_bodyweight_prompt_enabled, // This was commented out in your original code
            set_streak_interval,
            set_pb_notification_enabled,
            set_pb_notify_weight,
            set_pb_notify_reps,
            set_pb_notify_duration,
            set_pb_notify_distance,
            set_target_bodyweight,
            get_previous_workout_details,
            add_bodyweight_entry
        ])
        .run(tauri::generate_context!())
        .expect("error while running tauri application");
}


// src-tauri/src/main.rs
// Prevents additional console window on Windows in release, DO NOT REMOVE!!
#![cfg_attr(not(debug_assertions), windows_subsystem = "windows")]
use task_athlete_gui_lib::run;

fn main() {
    run();
}


// tailwind.config.js
// tailwind.config.js
/** @type {import('tailwindcss').Config} */
export default {
  content: [
    "./index.html",
    "./src/**/*.{js,ts,jsx,tsx}", // Adjust if your source files are elsewhere
  ],
  theme: {
    extend: {
      colors: {
      },
      boxShadow: {
        'themed-sm': '0 1px 2px 0 var(--color-shadow)',
        'themed-md': '0 4px 6px -1px var(--color-shadow), 0 2px 4px -2px var(--color-shadow)',
        'themed-lg': '0 10px 15px -3px var(--color-shadow), 0 4px 6px -4px var(--color-shadow)',
        'themed-xl': '0 20px 25px -5px var(--color-shadow), 0 8px 10px -6px var(--color-shadow)',
        'themed-2xl': '0 25px 50px -12px var(--color-shadow)',
        'themed-inner': 'inset 0 2px 4px 0 var(--color-shadow)',
      }
    },
  },
  plugins: [
    // require('@tailwindcss/forms'), // Uncomment if you use this plugin for form styling
  ],
}



